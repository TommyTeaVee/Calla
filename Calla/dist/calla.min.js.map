{"version":3,"file":"calla.min.js","sources":["../../Kudzu/typeChecks.ts","../audio/canChangeAudioOutput.ts","../node_modules/@microsoft/signalr/src/ILogger.ts","../node_modules/@microsoft/signalr/src/Errors.ts","../node_modules/@microsoft/signalr/src/HttpClient.ts","../node_modules/@microsoft/signalr/src/Loggers.ts","../node_modules/@microsoft/signalr/src/Utils.ts","../node_modules/@microsoft/signalr/src/FetchHttpClient.ts","../node_modules/@microsoft/signalr/src/IHubProtocol.ts","../node_modules/@microsoft/signalr/src/XhrHttpClient.ts","../node_modules/@microsoft/signalr/src/DefaultHttpClient.ts","../node_modules/@microsoft/signalr/src/TextMessageFormat.ts","../node_modules/@microsoft/signalr/src/HandshakeProtocol.ts","../node_modules/@microsoft/signalr/src/Subject.ts","../node_modules/@microsoft/signalr/src/HubConnection.ts","../node_modules/@microsoft/signalr/src/ITransport.ts","../node_modules/@microsoft/signalr/src/DefaultReconnectPolicy.ts","../node_modules/@microsoft/signalr/src/AbortController.ts","../node_modules/@microsoft/signalr/src/LongPollingTransport.ts","../node_modules/@microsoft/signalr/src/ServerSentEventsTransport.ts","../node_modules/@microsoft/signalr/src/WebSocketTransport.ts","../node_modules/@microsoft/signalr/src/HttpConnection.ts","../node_modules/@microsoft/signalr/src/JsonHubProtocol.ts","../node_modules/@microsoft/signalr/src/HubConnectionBuilder.ts","../CallaEvents.ts","../ConnectionState.ts","../../Kudzu/events/waitFor.ts","../../Kudzu/emoji/Emoji.ts","../../Kudzu/events/EventBase.ts","../../Kudzu/arrays/arrayRemoveAt.ts","../meta/BaseMetadataClient.ts","../../Kudzu/events/sleep.ts","../../Kudzu/arrays/arrayScan.ts","../tele/BaseTeleconferenceClient.ts","../audio/AudioActivityEvent.ts","../Calla.ts","../index.ts","../meta/signalr/SignalRMetadataClient.ts"],"sourcesContent":["function t(o: any, s: string, c: Function) {\r\n    return typeof o === s\r\n        || o instanceof c;\r\n}\r\n\r\nexport function isFunction(obj: any): obj is Function {\r\n    return t(obj, \"function\", Function);\r\n}\r\n\r\nexport function isString(obj: any): obj is string {\r\n    return t(obj, \"string\", String);\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n    return t(obj, \"boolean\", Boolean);\r\n}\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n    return t(obj, \"number\", Number);\r\n}\r\n\r\nexport function isObject(obj: any): obj is object {\r\n    return t(obj, \"object\", Object);\r\n}\r\n\r\nexport function isDate(obj: any): obj is Date {\r\n    return obj instanceof Date;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n    return obj instanceof Array;\r\n}\r\n\r\nexport function isHTMLElement(obj: any): obj is HTMLElement {\r\n    return obj instanceof HTMLElement;\r\n}\r\n\r\nexport function assertNever(x: never): never {\r\n    throw new Error(\"Unexpected object: \" + x);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is not the special NaN value.\r\n */\r\nexport function isGoodNumber(obj: any): obj is number {\r\n    return isNumber(obj)\r\n        && !Number.isNaN(obj);\r\n}\r\n\r\nexport function isEventListener(obj: EventListenerOrEventListenerObject): obj is EventListener {\r\n    return isFunction(obj);\r\n}\r\n\r\nexport function isEventListenerObject(obj: EventListenerOrEventListenerObject): obj is EventListenerObject {\r\n    return !isEventListener(obj);\r\n}\r\n\r\nexport function isNullOrUndefined(obj: any): obj is null | undefined {\r\n    return obj === null\r\n        || obj === undefined;\r\n}","import { isFunction } from \"kudzu/typeChecks\";\r\n\r\n/**\r\n * Indicates whether or not the current browser can change the destination device for audio output.\r\n **/\r\nexport const canChangeAudioOutput = isFunction((HTMLAudioElement.prototype as any).setSinkId);","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport enum LogLevel {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    Trace = 0,\r\n    /** Log level for low severity diagnostic messages. */\r\n    Debug = 1,\r\n    /** Log level for informational diagnostic messages. */\r\n    Information = 2,\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    Warning = 3,\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    Error = 4,\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    Critical = 5,\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    None = 6,\r\n}\r\n\r\n/** An abstraction that provides a sink for diagnostic messages. */\r\nexport interface ILogger {\r\n    /** Called by the framework to emit a diagnostic message.\r\n     *\r\n     * @param {LogLevel} logLevel The severity level of the message.\r\n     * @param {string} message The message.\r\n     */\r\n    log(logLevel: LogLevel, message: string): void;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // tslint:disable-next-line:variable-name\r\n    private __proto__: Error;\r\n\r\n    /** The HTTP status code represented by this error. */\r\n    public statusCode: number;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage: string, statusCode: number) {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        this.statusCode = statusCode;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // tslint:disable-next-line:variable-name\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // tslint:disable-next-line:variable-name\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortSignal } from \"./AbortController\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\n\r\n/** Represents an HTTP request. */\r\nexport interface HttpRequest {\r\n    /** The HTTP method to use for the request. */\r\n    method?: string;\r\n\r\n    /** The URL for the request. */\r\n    url?: string;\r\n\r\n    /** The body content for the request. May be a string or an ArrayBuffer (for binary data). */\r\n    content?: string | ArrayBuffer;\r\n\r\n    /** An object describing headers to apply to the request. */\r\n    headers?: MessageHeaders;\r\n\r\n    /** The XMLHttpRequestResponseType to apply to the request. */\r\n    responseType?: XMLHttpRequestResponseType;\r\n\r\n    /** An AbortSignal that can be monitored for cancellation. */\r\n    abortSignal?: AbortSignal;\r\n\r\n    /** The time to wait for the request to complete before throwing a TimeoutError. Measured in milliseconds. */\r\n    timeout?: number;\r\n\r\n    /** This controls whether credentials such as cookies are sent in cross-site requests. */\r\n    withCredentials?: boolean;\r\n}\r\n\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     */\r\n    constructor(statusCode: number);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code and message.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and string content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: ArrayBuffer);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string | ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string | ArrayBuffer);\r\n    constructor(\r\n        public readonly statusCode: number,\r\n        public readonly statusText?: string,\r\n        public readonly content?: string | ArrayBuffer) {\r\n    }\r\n}\r\n\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport abstract class HttpClient {\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public get(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public post(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public delete(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP request to the specified URL, returning a {@link Promise} that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {HttpRequest} request An {@link @microsoft/signalr.HttpRequest} describing the request to send.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an HttpResponse describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public abstract send(request: HttpRequest): Promise<HttpResponse>;\r\n\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    public getCookieString(url: string): string {\r\n        return \"\";\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger implements ILogger {\r\n    /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\n    public static instance: ILogger = new NullLogger();\r\n\r\n    private constructor() {}\r\n\r\n    /** @inheritDoc */\r\n    // tslint:disable-next-line\r\n    public log(_logLevel: LogLevel, _message: string): void {\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\n\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexport const VERSION: string = \"0.0.0-DEV_BUILD\";\r\n\r\n/** @private */\r\nexport class Arg {\r\n    public static isRequired(val: any, name: string): void {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    public static isNotEmpty(val: string, name: string): void {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n\r\n    public static isIn(val: any, values: any, name: string): void {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class Platform {\r\n    public static get isBrowser(): boolean {\r\n        return typeof window === \"object\";\r\n    }\r\n\r\n    public static get isWebWorker(): boolean {\r\n        return typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n\r\n    public static get isNode(): boolean {\r\n        return !this.isBrowser && !this.isWebWorker;\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getDataDetail(data: any, includeContent: boolean): string {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    } else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n\r\n/** @private */\r\nexport function formatArrayBuffer(data: ArrayBuffer): string {\r\n    const view = new Uint8Array(data);\r\n\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\n/** @private */\r\nexport async function sendMessage(logger: ILogger, transportName: string, httpClient: HttpClient, url: string, accessTokenFactory: (() => string | Promise<string>) | undefined,\r\n                                  content: string | ArrayBuffer, logMessageContent: boolean, withCredentials: boolean, defaultHeaders: MessageHeaders): Promise<void> {\r\n    let headers = {};\r\n    if (accessTokenFactory) {\r\n        const token = await accessTokenFactory();\r\n        if (token) {\r\n            headers = {\r\n                [\"Authorization\"]: `Bearer ${token}`,\r\n            };\r\n        }\r\n    }\r\n\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, logMessageContent)}.`);\r\n\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...defaultHeaders},\r\n        responseType,\r\n        withCredentials,\r\n    });\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n\r\n/** @private */\r\nexport function createLogger(logger?: ILogger | LogLevel) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n\r\n    if ((logger as ILogger).log) {\r\n        return logger as ILogger;\r\n    }\r\n\r\n    return new ConsoleLogger(logger as LogLevel);\r\n}\r\n\r\n/** @private */\r\nexport class SubjectSubscription<T> implements ISubscription<T> {\r\n    private subject: Subject<T>;\r\n    private observer: IStreamSubscriber<T>;\r\n\r\n    constructor(subject: Subject<T>, observer: IStreamSubscriber<T>) {\r\n        this.subject = subject;\r\n        this.observer = observer;\r\n    }\r\n\r\n    public dispose(): void {\r\n        const index: number = this.subject.observers.indexOf(this.observer);\r\n        if (index > -1) {\r\n            this.subject.observers.splice(index, 1);\r\n        }\r\n\r\n        if (this.subject.observers.length === 0 && this.subject.cancelCallback) {\r\n            this.subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class ConsoleLogger implements ILogger {\r\n    private readonly minimumLogLevel: LogLevel;\r\n\r\n    // Public for testing purposes.\r\n    public outputConsole: {\r\n        error(message: any): void,\r\n        warn(message: any): void,\r\n        info(message: any): void,\r\n        log(message: any): void,\r\n    };\r\n\r\n    constructor(minimumLogLevel: LogLevel) {\r\n        this.minimumLogLevel = minimumLogLevel;\r\n        this.outputConsole = console;\r\n    }\r\n\r\n    public log(logLevel: LogLevel, message: string): void {\r\n        if (logLevel >= this.minimumLogLevel) {\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.outputConsole.error(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.outputConsole.warn(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.outputConsole.info(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.outputConsole.log(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getUserAgentHeader(): [string, string] {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [ userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion()) ];\r\n}\r\n\r\n/** @private */\r\nexport function constructUserAgent(version: string, os: string, runtime: string, runtimeVersion: string | undefined): string {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent: string = \"Microsoft SignalR/\";\r\n\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    } else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n\r\n    userAgent += `${runtime}`;\r\n\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    } else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n\r\nfunction getOsName(): string {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}\r\n\r\nfunction getRuntimeVersion(): string | undefined {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getRuntime(): string {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    } else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport * as tough from \"@types/tough-cookie\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { Platform } from \"./Utils\";\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly jar?: tough.CookieJar;\r\n\r\n    private readonly logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this.logger = logger;\r\n\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this.jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this.fetchType = requireFunc(\"node-fetch\");\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this.fetchType = requireFunc(\"fetch-cookie\")(this.fetchType, this.jar);\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this.abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this.fetchType = fetch.bind(self);\r\n            this.abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this.abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this.fetchType(request.url!, {\r\n                body: request.content!,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"manual\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this.logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            throw new HttpError(response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        let cookies: string = \"\";\r\n        if (Platform.isNode && this.jar) {\r\n            // @ts-ignore: unused variable\r\n            this.jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { ILogger } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\n\r\n/** Defines the type of a Hub Message. */\r\nexport enum MessageType {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    Invocation = 1,\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    StreamItem = 2,\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    Completion = 3,\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    StreamInvocation = 4,\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    CancelInvocation = 5,\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    Ping = 6,\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    Close = 7,\r\n}\r\n\r\n/** Defines a dictionary of string keys and string values representing headers attached to a Hub message. */\r\nexport interface MessageHeaders {\r\n    /** Gets or sets the header with the specified key. */\r\n    [key: string]: string;\r\n}\r\n\r\n/** Union type of all known Hub messages. */\r\nexport type HubMessage =\r\n    InvocationMessage |\r\n    StreamInvocationMessage |\r\n    StreamItemMessage |\r\n    CompletionMessage |\r\n    CancelInvocationMessage |\r\n    PingMessage |\r\n    CloseMessage;\r\n\r\n/** Defines properties common to all Hub messages. */\r\nexport interface HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageType} value indicating the type of this message. */\r\n    readonly type: MessageType;\r\n}\r\n\r\n/** Defines properties common to all Hub messages relating to a specific invocation. */\r\nexport interface HubInvocationMessage extends HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageHeaders} dictionary containing headers attached to the message. */\r\n    readonly headers?: MessageHeaders;\r\n    /** The ID of the invocation relating to this message.\r\n     *\r\n     * This is expected to be present for {@link @microsoft/signalr.StreamInvocationMessage} and {@link @microsoft/signalr.CompletionMessage}. It may\r\n     * be 'undefined' for an {@link @microsoft/signalr.InvocationMessage} if the sender does not expect a response.\r\n     */\r\n    readonly invocationId?: string;\r\n}\r\n\r\n/** A hub message representing a non-streaming invocation. */\r\nexport interface InvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Invocation;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a streaming invocation. */\r\nexport interface StreamInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamInvocation;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a single item produced as part of a result stream. */\r\nexport interface StreamItemMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamItem;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n\r\n    /** The item produced by the server. */\r\n    readonly item?: any;\r\n}\r\n\r\n/** A hub message representing the result of an invocation. */\r\nexport interface CompletionMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Completion;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The error produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly error?: string;\r\n    /** The result produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly result?: any;\r\n}\r\n\r\n/** A hub message indicating that the sender is still active. */\r\nexport interface PingMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Ping;\r\n}\r\n\r\n/** A hub message indicating that the sender is closing the connection.\r\n *\r\n * If {@link @microsoft/signalr.CloseMessage.error} is defined, the sender is closing the connection due to an error.\r\n */\r\nexport interface CloseMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Close;\r\n    /** The error that triggered the close, if any.\r\n     *\r\n     * If this property is undefined, the connection was closed normally and without error.\r\n     */\r\n    readonly error?: string;\r\n\r\n    /** If true, clients with automatic reconnects enabled should attempt to reconnect after receiving the CloseMessage. Otherwise, they should not. */\r\n    readonly allowReconnect?: boolean;\r\n}\r\n\r\n/** A hub message sent to request that a streaming invocation be canceled. */\r\nexport interface CancelInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.CancelInvocation;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n}\r\n\r\n/** A protocol abstraction for communicating with SignalR Hubs.  */\r\nexport interface IHubProtocol {\r\n    /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n    readonly name: string;\r\n    /** The version of the protocol. */\r\n    readonly version: number;\r\n    /** The {@link @microsoft/signalr.TransferFormat} of the protocol. */\r\n    readonly transferFormat: TransferFormat;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the `input` parameter must be a string, otherwise it must be an ArrayBuffer.\r\n     *\r\n     * @param {string | ArrayBuffer | Buffer} input A string, ArrayBuffer, or Buffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input: string | ArrayBuffer | Buffer, logger: ILogger): HubMessage[];\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string or ArrayBuffer and returns it.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the result of this method will be a string, otherwise it will be an ArrayBuffer.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string | ArrayBuffer} A string or ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message: HubMessage): string | ArrayBuffer;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\nexport class XhrHttpClient extends HttpClient {\r\n    private readonly logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this.logger = logger;\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return new Promise<HttpResponse>((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n\r\n            xhr.open(request.method!, request.url!, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                        xhr.setRequestHeader(header, headers[header]);\r\n                    });\r\n            }\r\n\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                } else {\r\n                    reject(new HttpError(xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n\r\n            xhr.onerror = () => {\r\n                this.logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n\r\n            xhr.ontimeout = () => {\r\n                this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n\r\n            xhr.send(request.content || \"\");\r\n        });\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger } from \"./ILogger\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    private readonly httpClient: HttpClient;\r\n\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this.httpClient = new FetchHttpClient(logger);\r\n        } else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this.httpClient = new XhrHttpClient(logger);\r\n        } else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return this.httpClient.send(request);\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this.httpClient.getCookieString(url);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    public static RecordSeparatorCode = 0x1e;\r\n    public static RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n\r\n    public static write(output: string): string {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n\r\n    public static parse(input: string): string[] {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n/** @private */\r\nexport interface HandshakeRequestMessage {\r\n    readonly protocol: string;\r\n    readonly version: number;\r\n}\r\n\r\n/** @private */\r\nexport interface HandshakeResponseMessage {\r\n    readonly error: string;\r\n    readonly minorVersion: number;\r\n}\r\n\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    public writeHandshakeRequest(handshakeRequest: HandshakeRequestMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n\r\n    public parseHandshakeResponse(data: any): [any, HandshakeResponseMessage] {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let messageData: string;\r\n        let remainingData: any;\r\n\r\n        if (isArrayBuffer(data) || (typeof Buffer !== \"undefined\" && data instanceof Buffer)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        } else {\r\n            const textData: string = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        responseMessage = response;\r\n\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { IStreamResult, IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { SubjectSubscription } from \"./Utils\";\r\n\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject<T> implements IStreamResult<T> {\r\n    /** @internal */\r\n    public observers: Array<IStreamSubscriber<T>>;\r\n\r\n    /** @internal */\r\n    public cancelCallback?: () => Promise<void>;\r\n\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n\r\n    public next(item: T): void {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n\r\n    public error(err: any): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    public complete(): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n\r\n    public subscribe(observer: IStreamSubscriber<T>): ISubscription<T> {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg } from \"./Utils\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\r\n\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport enum HubConnectionState {\r\n    /** The hub connection is disconnected. */\r\n    Disconnected = \"Disconnected\",\r\n    /** The hub connection is connecting. */\r\n    Connecting = \"Connecting\",\r\n    /** The hub connection is connected. */\r\n    Connected = \"Connected\",\r\n    /** The hub connection is disconnecting. */\r\n    Disconnecting = \"Disconnecting\",\r\n    /** The hub connection is reconnecting. */\r\n    Reconnecting = \"Reconnecting\",\r\n}\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly cachedPingMessage: string | ArrayBuffer;\r\n    private readonly connection: IConnection;\r\n    private readonly logger: ILogger;\r\n    private readonly reconnectPolicy?: IRetryPolicy;\r\n    private protocol: IHubProtocol;\r\n    private handshakeProtocol: HandshakeProtocol;\r\n    private callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\r\n    private methods: { [name: string]: Array<(...args: any[]) => void> };\r\n    private invocationId: number;\r\n\r\n    private closedCallbacks: Array<(error?: Error) => void>;\r\n    private reconnectingCallbacks: Array<(error?: Error) => void>;\r\n    private reconnectedCallbacks: Array<(connectionId?: string) => void>;\r\n\r\n    private receivedHandshakeResponse: boolean;\r\n    private handshakeResolver!: (value?: PromiseLike<{}>) => void;\r\n    private handshakeRejecter!: (reason?: any) => void;\r\n    private stopDuringStartError?: Error;\r\n\r\n    private connectionState: HubConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private connectionStarted: boolean;\r\n    private startPromise?: Promise<void>;\r\n    private stopPromise?: Promise<void>;\r\n\r\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\r\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\r\n    // we built the bundle from the compiled JavaScript).\r\n    private reconnectDelayHandle?: any;\r\n    private timeoutHandle?: any;\r\n    private pingServerHandle?: any;\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** Default interval at which to ping the server.\r\n     *\r\n     * The default value is 15,000 milliseconds (15 seconds).\r\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\r\n     */\r\n    public keepAliveIntervalInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy): HubConnection {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    }\r\n\r\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.reconnectPolicy = reconnectPolicy;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this.processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this.connectionClosed(error);\r\n\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.reconnectingCallbacks = [];\r\n        this.reconnectedCallbacks = [];\r\n        this.invocationId = 0;\r\n        this.receivedHandshakeResponse = false;\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n\r\n        this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state(): HubConnectionState {\r\n        return this.connectionState;\r\n    }\r\n\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId(): string | null {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl(): string {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url: string) {\r\n        if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n\r\n        this.connection.baseUrl = url;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public start(): Promise<void> {\r\n        this.startPromise = this.startWithStateTransitions();\r\n        return this.startPromise;\r\n    }\r\n\r\n    private async startWithStateTransitions(): Promise<void> {\r\n        if (this.connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Connecting;\r\n        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        try {\r\n            await this.startInternal();\r\n\r\n            this.connectionState = HubConnectionState.Connected;\r\n            this.connectionStarted = true;\r\n            this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        } catch (e) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async startInternal() {\r\n        this.stopDuringStartError = undefined;\r\n        this.receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this.handshakeResolver = resolve;\r\n            this.handshakeRejecter = reject;\r\n        });\r\n\r\n        await this.connection.start(this.protocol.transferFormat);\r\n\r\n        try {\r\n            const handshakeRequest: HandshakeRequestMessage = {\r\n                protocol: this.protocol.name,\r\n                version: this.protocol.version,\r\n            };\r\n\r\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n            await this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n            this.logger.log(LogLevel.Information, `Using HubProtocol '${this.protocol.name}'.`);\r\n\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this.cleanupTimeout();\r\n            this.resetTimeoutPeriod();\r\n            this.resetKeepAliveInterval();\r\n\r\n            await handshakePromise;\r\n\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this.stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                throw this.stopDuringStartError;\r\n            }\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n\r\n            this.cleanupTimeout();\r\n            this.cleanupPingTimer();\r\n\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public async stop(): Promise<void> {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this.startPromise;\r\n\r\n        this.stopPromise = this.stopInternal();\r\n        await this.stopPromise;\r\n\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n\r\n    private stopInternal(error?: Error): Promise<void> {\r\n        if (this.connectionState === HubConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this.stopPromise!;\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Disconnecting;\r\n\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        if (this.reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n\r\n            clearTimeout(this.reconnectDelayHandle);\r\n            this.reconnectDelayHandle = undefined;\r\n\r\n            this.completeClose();\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\r\n\r\n        let promiseQueue: Promise<void>;\r\n        const subject = new Subject<T>();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation: CancelInvocationMessage = this.createCancelInvocation(invocationDescriptor.invocationId);\r\n\r\n            delete this.callbacks[invocationDescriptor.invocationId];\r\n\r\n            return promiseQueue.then(() => {\r\n                return this.sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n\r\n        this.callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            } else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    } else {\r\n                        subject.complete();\r\n                    }\r\n                } else {\r\n                    subject.next((invocationEvent.item) as T);\r\n                }\r\n            }\r\n        };\r\n\r\n        promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        this.launchStreams(streams, promiseQueue);\r\n\r\n        return subject;\r\n    }\r\n\r\n    private sendMessage(message: any) {\r\n        this.resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    private sendWithProtocol(message: any) {\r\n        return this.sendMessage(this.protocol.writeMessage(message));\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\r\n\r\n        this.launchStreams(streams, sendPromise);\r\n\r\n        return sendPromise;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this.callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                } else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        } else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    } else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    // invocationId will always have a value for a non-blocking invocation\r\n                    delete this.callbacks[invocationDescriptor.invocationId!];\r\n                });\r\n\r\n            this.launchStreams(streams, promiseQueue);\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => void) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this.methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    public onreconnecting(callback: (error?: Error) => void) {\r\n        if (callback) {\r\n            this.reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    public onreconnected(callback: (connectionId?: string) => void) {\r\n        if (callback) {\r\n            this.reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private processIncomingData(data: any) {\r\n        this.cleanupTimeout();\r\n\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this.protocol.parseMessages(data, this.logger);\r\n\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        const callback = this.callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n\r\n                            // tslint:disable-next-line:no-floating-promises\r\n                            this.connection.stop(error);\r\n                        } else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this.stopPromise = this.stopInternal(error);\r\n                        }\r\n\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.resetTimeoutPeriod();\r\n    }\r\n\r\n    private processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this.handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        this.handshakeResolver();\r\n        return remainingData;\r\n    }\r\n\r\n    private resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n\r\n        this.cleanupPingTimer();\r\n        this.pingServerHandle = setTimeout(async () => {\r\n            if (this.connectionState === HubConnectionState.Connected) {\r\n                try {\r\n                    await this.sendMessage(this.cachedPingMessage);\r\n                } catch {\r\n                    // We don't care about the error. It should be seen elsewhere in the client.\r\n                    // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                    this.cleanupPingTimer();\r\n                }\r\n            }\r\n        }, this.keepAliveIntervalInMilliseconds);\r\n    }\r\n\r\n    private resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n        }\r\n    }\r\n\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach((m) => m.apply(this, invocationMessage.arguments));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `A callback for the method ${invocationMessage.target.toLowerCase()} threw error '${e}'.`);\r\n            }\r\n\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n\r\n                // We don't want to wait on the stop itself.\r\n                this.stopPromise = this.stopInternal(new Error(message));\r\n            }\r\n        } else {\r\n            this.logger.log(LogLevel.Warning, `No client method with the name '${invocationMessage.target}' found.`);\r\n        }\r\n    }\r\n\r\n    private connectionClosed(error?: Error) {\r\n        this.logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this.connectionState}.`);\r\n\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this.handshakeResolver) {\r\n            this.handshakeResolver();\r\n        }\r\n\r\n        this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.completeClose(error);\r\n        } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.reconnect(error);\r\n        } else if (this.connectionState === HubConnectionState.Connected) {\r\n            this.completeClose(error);\r\n        }\r\n\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n\r\n    private completeClose(error?: Error) {\r\n        if (this.connectionStarted) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.connectionStarted = false;\r\n\r\n            try {\r\n                this.closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async reconnect(error?: Error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n\r\n        let nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n\r\n        if (nextRetryDelay === null) {\r\n            this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this.completeClose(error);\r\n            return;\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Reconnecting;\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n\r\n        if (this.onreconnecting) {\r\n            try {\r\n                this.reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        while (nextRetryDelay !== null) {\r\n            this.logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n\r\n            await new Promise((resolve) => {\r\n                this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\r\n            });\r\n            this.reconnectDelayHandle = undefined;\r\n\r\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this.startInternal();\r\n\r\n                this.connectionState = HubConnectionState.Connected;\r\n                this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n\r\n                if (this.onreconnected) {\r\n                    try {\r\n                        this.reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    } catch (e) {\r\n                        this.logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n\r\n                if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                    this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect attempt. Done reconnecting.\");\r\n                    return;\r\n                }\r\n\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n\r\n        this.logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n\r\n        this.completeClose();\r\n    }\r\n\r\n    private getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\r\n        try {\r\n            return this.reconnectPolicy!.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private cancelCallbacksWithError(error: Error) {\r\n        const callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                callback(null, error);\r\n            });\r\n    }\r\n\r\n    private cleanupPingTimer(): void {\r\n        if (this.pingServerHandle) {\r\n            clearTimeout(this.pingServerHandle);\r\n        }\r\n    }\r\n\r\n    private cleanupTimeout(): void {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        } else {\r\n            const invocationId = this.invocationId;\r\n            this.invocationId++;\r\n\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private launchStreams(streams: Array<IStreamResult<any>>, promiseQueue: Promise<void>): void {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // tslint:disable-next-line:forin\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message: string;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    } else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    } else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    private replaceStreamingParams(args: any[]): [Array<IStreamResult<any>>, string[]] {\r\n        const streams: Array<IStreamResult<any>> = [];\r\n        const streamIds: string[] = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this.isObservable(argument)) {\r\n                const streamId = this.invocationId;\r\n                this.invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        return [streams, streamIds];\r\n    }\r\n\r\n    private isObservable(arg: any): arg is IStreamResult<any> {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n\r\n    private createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\r\n        const invocationId = this.invocationId;\r\n        this.invocationId++;\r\n\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        } else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n\r\n    private createStreamItemMessage(id: string, item: any): StreamItemMessage {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n\r\n    private createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport enum HttpTransportType {\r\n    /** Specifies no transport preference. */\r\n    None = 0,\r\n    /** Specifies the WebSockets transport. */\r\n    WebSockets = 1,\r\n    /** Specifies the Server-Sent Events transport. */\r\n    ServerSentEvents = 2,\r\n    /** Specifies the Long Polling transport. */\r\n    LongPolling = 4,\r\n}\r\n\r\n/** Specifies the transfer format for a connection. */\r\nexport enum TransferFormat {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    Text = 1,\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    Binary = 2,\r\n}\r\n\r\n/** An abstraction over the behavior of transports. This is designed to support the framework and not intended for use by applications. */\r\nexport interface ITransport {\r\n    connect(url: string, transferFormat: TransferFormat): Promise<void>;\r\n    send(data: any): Promise<void>;\r\n    stop(): Promise<void>;\r\n    onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    onclose: ((error?: Error) => void) | null;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { IRetryPolicy, RetryContext } from \"./IRetryPolicy\";\r\n\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n\r\n/** @private */\r\nexport class DefaultReconnectPolicy implements IRetryPolicy {\r\n    private readonly retryDelays: Array<number | null>;\r\n\r\n    constructor(retryDelays?: number[]) {\r\n        this.retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n\r\n    public nextRetryDelayInMilliseconds(retryContext: RetryContext): number | null {\r\n        return this.retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController implements AbortSignal {\r\n    private isAborted: boolean = false;\r\n    public onabort: (() => void) | null = null;\r\n\r\n    public abort() {\r\n        if (!this.isAborted) {\r\n            this.isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n\r\n    get signal(): AbortSignal {\r\n        return this;\r\n    }\r\n\r\n    get aborted(): boolean {\r\n        return this.isAborted;\r\n    }\r\n}\r\n\r\n/** Represents a signal that can be monitored to determine if a request has been aborted. */\r\nexport interface AbortSignal {\r\n    /** Indicates if the request has been aborted. */\r\n    aborted: boolean;\r\n    /** Set this to a handler that will be invoked when the request is aborted. */\r\n    onabort: (() => void) | null;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\n\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport implements ITransport {\r\n    private readonly httpClient: HttpClient;\r\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly logger: ILogger;\r\n    private readonly logMessageContent: boolean;\r\n    private readonly withCredentials: boolean;\r\n    private readonly pollAbort: AbortController;\r\n    private readonly headers: MessageHeaders;\r\n\r\n    private url?: string;\r\n    private running: boolean;\r\n    private receiving?: Promise<void>;\r\n    private closeError?: Error;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    public get pollAborted() {\r\n        return this.pollAbort.aborted;\r\n    }\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger, logMessageContent: boolean, withCredentials: boolean, headers: MessageHeaders) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logger = logger;\r\n        this.pollAbort = new AbortController();\r\n        this.logMessageContent = logMessageContent;\r\n        this.withCredentials = withCredentials;\r\n        this.headers = headers;\r\n\r\n        this.running = false;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.url = url;\r\n\r\n        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this.headers };\r\n\r\n        const pollOptions: HttpRequest = {\r\n            abortSignal: this.pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this.withCredentials,\r\n        };\r\n\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n\r\n        const token = await this.getAccessToken();\r\n        this.updateHeaderToken(pollOptions, token);\r\n\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this.logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this.httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this.logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this.running = false;\r\n        } else {\r\n            this.running = true;\r\n        }\r\n\r\n        this.receiving = this.poll(this.url, pollOptions);\r\n    }\r\n\r\n    private async getAccessToken(): Promise<string | null> {\r\n        if (this.accessTokenFactory) {\r\n            return await this.accessTokenFactory();\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private updateHeaderToken(request: HttpRequest, token: string | null) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (token) {\r\n            // tslint:disable-next-line:no-string-literal\r\n            request.headers[\"Authorization\"] = `Bearer ${token}`;\r\n            return;\r\n        }\r\n        // tslint:disable-next-line:no-string-literal\r\n        if (request.headers[\"Authorization\"]) {\r\n            // tslint:disable-next-line:no-string-literal\r\n            delete request.headers[\"Authorization\"];\r\n        }\r\n    }\r\n\r\n    private async poll(url: string, pollOptions: HttpRequest): Promise<void> {\r\n        try {\r\n            while (this.running) {\r\n                // We have to get the access token on each poll, in case it changes\r\n                const token = await this.getAccessToken();\r\n                this.updateHeaderToken(pollOptions, token);\r\n\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this.logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this.httpClient.get(pollUrl, pollOptions);\r\n\r\n                    if (response.statusCode === 204) {\r\n                        this.logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n\r\n                        this.running = false;\r\n                    } else if (response.statusCode !== 200) {\r\n                        this.logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n                        // Unexpected status code\r\n                        this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this.running = false;\r\n                    } else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this.logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this.logMessageContent)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        } else {\r\n                            // This is another way timeout manifest.\r\n                            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    if (!this.running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this.logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    } else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        } else {\r\n                            // Close the connection with the error as the result.\r\n                            this.closeError = e;\r\n                            this.running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this.raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this.running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this.logger, \"LongPolling\", this.httpClient, this.url!, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers);\r\n    }\r\n\r\n    public async stop(): Promise<void> {\r\n        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this.running = false;\r\n        this.pollAbort.abort();\r\n\r\n        try {\r\n            await this.receiving;\r\n\r\n            // Send DELETE to clean up long polling on the server\r\n            this.logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this.url}.`);\r\n\r\n            const headers = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n\r\n            const deleteOptions: HttpRequest = {\r\n                headers: { ...headers, ...this.headers },\r\n                withCredentials: this.withCredentials,\r\n            };\r\n            const token = await this.getAccessToken();\r\n            this.updateHeaderToken(deleteOptions, token);\r\n            await this.httpClient.delete(this.url!, deleteOptions);\r\n\r\n            this.logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\r\n        } finally {\r\n            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this.raiseOnClose();\r\n        }\r\n    }\r\n\r\n    private raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this.closeError) {\r\n                logMessage += \" Error: \" + this.closeError;\r\n            }\r\n            this.logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this.closeError);\r\n        }\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { EventSourceConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly httpClient: HttpClient;\r\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly logger: ILogger;\r\n    private readonly logMessageContent: boolean;\r\n    private readonly withCredentials: boolean;\r\n    private readonly eventSourceConstructor: EventSourceConstructor;\r\n    private eventSource?: EventSource;\r\n    private url?: string;\r\n    private headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, eventSourceConstructor: EventSourceConstructor, withCredentials: boolean, headers: MessageHeaders) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logger = logger;\r\n        this.logMessageContent = logMessageContent;\r\n        this.withCredentials = withCredentials;\r\n        this.eventSourceConstructor = eventSourceConstructor;\r\n        this.headers = headers;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\r\n        this.url = url;\r\n\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this.eventSourceConstructor(url, { withCredentials: this.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this.httpClient.getCookieString(url);\r\n                const headers: MessageHeaders = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this.eventSourceConstructor(url, { withCredentials: this.withCredentials, headers: { ...headers, ...this.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this.logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this.close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                eventSource.onerror = (e: MessageEvent) => {\r\n                    const error = new Error(e.data || \"Error occurred\");\r\n                    if (opened) {\r\n                        this.close(error);\r\n                    } else {\r\n                        reject(error);\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this.logger.log(LogLevel.Information, `SSE connected to ${this.url}`);\r\n                    this.eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this.eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this.logger, \"SSE\", this.httpClient, this.url!, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this.close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private close(e?: Error) {\r\n        if (this.eventSource) {\r\n            this.eventSource.close();\r\n            this.eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly logger: ILogger;\r\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly logMessageContent: boolean;\r\n    private readonly webSocketConstructor: WebSocketConstructor;\r\n    private readonly httpClient: HttpClient;\r\n    private webSocket?: WebSocket;\r\n    private headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this.logger = logger;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logMessageContent = logMessageContent;\r\n        this.webSocketConstructor = webSocketConstructor;\r\n        this.httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this.headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this.httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode) {\r\n                const headers = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                if (cookies) {\r\n                    headers[`Cookie`] = `${cookies}`;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this.webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this.headers },\r\n                });\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this.webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            // tslint:disable-next-line:variable-name\r\n            webSocket.onopen = (_event: Event) => {\r\n                this.logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this.webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = new Error(\"There was an error with the transport.\");\r\n                }\r\n\r\n                reject(error);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this.logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this.logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this.close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this.close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = new Error(\"There was an error with the transport.\");\r\n                    }\r\n\r\n                    reject(error);\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {\r\n            this.logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this.logMessageContent)}.`);\r\n            this.webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this.webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this.close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private close(event?: CloseEvent | Error): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this.webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this.webSocket.onclose = () => {};\r\n            this.webSocket.onmessage = () => {};\r\n            this.webSocket.onerror = () => {};\r\n            this.webSocket.close();\r\n            this.webSocket = undefined;\r\n        }\r\n\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this.isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: Array<keyof typeof TransferFormat>;\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private connectionStarted: boolean;\r\n    private readonly httpClient: HttpClient;\r\n    private readonly logger: ILogger;\r\n    private readonly options: IHttpConnectionOptions;\r\n    private transport?: ITransport;\r\n    private startInternalPromise?: Promise<void>;\r\n    private stopPromise?: Promise<void>;\r\n    private stopPromiseResolver!: (value?: PromiseLike<void>) => void;\r\n    private stopError?: Error;\r\n    private accessTokenFactory?: () => string | Promise<string>;\r\n    private sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this.logger = createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        } else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n\r\n        let webSocketModule: any = null;\r\n        let eventSourceModule: any = null;\r\n\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        } else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        } else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n\r\n        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\r\n        this.connectionState = ConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n        this.options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this.connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Connecting;\r\n\r\n        this.startInternalPromise = this.startInternal(transferFormat);\r\n        await this.startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this.connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this.stopPromise;\r\n\r\n            return Promise.reject(new Error(message));\r\n        } else if (this.connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this.logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new Error(message));\r\n        }\r\n\r\n        this.connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this.connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this.sendQueue) {\r\n            this.sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this.sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this.stopPromise;\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Disconnecting;\r\n\r\n        this.stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this.stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this.stopInternal(error);\r\n        await this.stopPromise;\r\n    }\r\n\r\n    private async stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this.stopError = error;\r\n\r\n        try {\r\n            await this.startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this.stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n            this.stopConnection();\r\n        }\r\n    }\r\n\r\n    private async startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this.accessTokenFactory = this.options.accessTokenFactory;\r\n\r\n        try {\r\n            if (this.options.skipNegotiation) {\r\n                if (this.options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this.constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this.startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this.getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this.connectionState === ConnectionState.Disconnecting || this.connectionState === ConnectionState.Disconnected) {\r\n                        throw new Error(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this.accessTokenFactory = () => accessToken;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this.connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this.connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this.connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const headers = {};\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                headers[`Authorization`] = `Bearer ${token}`;\r\n            }\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n\r\n        const negotiateUrl = this.resolveNegotiateUrl(url);\r\n        this.logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this.httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this.options.headers },\r\n                withCredentials: this.options.withCredentials,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this.isITransport(requestedTransport)) {\r\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this.startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed: ${transportOrError}`);\r\n            } else if (this.isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this.getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this.startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this.logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(`${endpoint.transport} failed: ${ex}`);\r\n\r\n                    if (this.connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this.logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new Error(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new Error(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this.options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket, this.options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this.options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials!, this.options.headers || {});\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials!, this.options.headers || {});\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        this.transport!.onclose = (e) => this.stopConnection(e);\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {\r\n                        this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new Error(`'${HttpTransportType[transport]}' is not supported in your environment.`);\r\n                    } else {\r\n                        this.logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this.constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new Error(`'${HttpTransportType[transport]}' is disabled by the client.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private stopConnection(error?: Error): void {\r\n        this.logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this.connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this.stopError || error;\r\n        this.stopError = undefined;\r\n\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Connecting) {\r\n            this.logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this.stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this.sendQueue) {\r\n            this.sendQueue.stop().catch((e) => {\r\n                this.logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this.sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this.connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this.connectionStarted) {\r\n            this.connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser || !window.document) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this.logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private buffer: any[] = [];\r\n    private sendBufferedData: PromiseSource;\r\n    private executing: boolean = true;\r\n    private transportResult?: PromiseSource;\r\n    private sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly transport: ITransport) {\r\n        this.sendBufferedData = new PromiseSource();\r\n        this.transportResult = new PromiseSource();\r\n\r\n        this.sendLoopPromise = this.sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this.bufferData(data);\r\n        if (!this.transportResult) {\r\n            this.transportResult = new PromiseSource();\r\n        }\r\n        return this.transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this.executing = false;\r\n        this.sendBufferedData.resolve();\r\n        return this.sendLoopPromise;\r\n    }\r\n\r\n    private bufferData(data: string | ArrayBuffer): void {\r\n        if (this.buffer.length && typeof(this.buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this.buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this.buffer.push(data);\r\n        this.sendBufferedData.resolve();\r\n    }\r\n\r\n    private async sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this.sendBufferedData.promise;\r\n\r\n            if (!this.executing) {\r\n                if (this.transportResult) {\r\n                    this.transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this.sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this.transportResult!;\r\n            this.transportResult = undefined;\r\n\r\n            const data = typeof(this.buffer[0]) === \"string\" ?\r\n                this.buffer.join(\"\") :\r\n                TransportSendQueue.concatBuffers(this.buffer);\r\n\r\n            this.buffer.length = 0;\r\n\r\n            try {\r\n                await this.transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result.buffer;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private resolver?: () => void;\r\n    private rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this.resolver, this.rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this.resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this.rejecter!(reason);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { CompletionMessage, HubMessage, IHubProtocol, InvocationMessage, MessageType, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\n\r\nconst JSON_HUB_PROTOCOL_NAME: string = \"json\";\r\n\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol implements IHubProtocol {\r\n\r\n    /** @inheritDoc */\r\n    public readonly name: string = JSON_HUB_PROTOCOL_NAME;\r\n    /** @inheritDoc */\r\n    public readonly version: number = 1;\r\n\r\n    /** @inheritDoc */\r\n    public readonly transferFormat: TransferFormat = TransferFormat.Text;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    public parseMessages(input: string, logger: ILogger): HubMessage[] {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n\r\n        if (!input) {\r\n            return [];\r\n        }\r\n\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message) as HubMessage;\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this.isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this.isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this.isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n\r\n        return hubMessages;\r\n    }\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    public writeMessage(message: HubMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n\r\n    private isInvocationMessage(message: InvocationMessage): void {\r\n        this.assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n\r\n        if (message.invocationId !== undefined) {\r\n            this.assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n\r\n    private isStreamItemMessage(message: StreamItemMessage): void {\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n\r\n    private isCompletionMessage(message: CompletionMessage): void {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        if (!message.result && message.error) {\r\n            this.assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n\r\n    private assertNotEmptyString(value: any, errorMessage: string): void {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { IHubProtocol } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { HttpTransportType } from \"./ITransport\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\n\r\n// tslint:disable:object-literal-sort-keys\r\nconst LogLevelNameMapping = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\n\r\nfunction parseLogLevel(name: string): LogLevel {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    } else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    /** @internal */\r\n    public protocol?: IHubProtocol;\r\n    /** @internal */\r\n    public httpConnectionOptions?: IHttpConnectionOptions;\r\n    /** @internal */\r\n    public url?: string;\r\n    /** @internal */\r\n    public logger?: ILogger;\r\n\r\n    /** If defined, this indicates the client should automatically attempt to reconnect if the connection is lost. */\r\n    /** @internal */\r\n    public reconnectPolicy?: IRetryPolicy;\r\n\r\n    /** Configures console logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel} logLevel The minimum level of messages to log. Anything at this level, or a more severe level, will be logged.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logLevel: LogLevel): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {ILogger} logger An object implementing the {@link @microsoft/signalr.ILogger} interface, which will be used to write all log messages.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logger: ILogger): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {string} logLevel A string representing a LogLevel setting a minimum level of messages to log.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     */\r\n    public configureLogging(logLevel: string): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel | string | ILogger} logging A {@link @microsoft/signalr.LogLevel}, a string representing a LogLevel, or an object implementing the {@link @microsoft/signalr.ILogger} interface.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder;\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder {\r\n        Arg.isRequired(logging, \"logging\");\r\n\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        } else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        } else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * The transport will be selected automatically based on what the server and client support.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified HTTP-based transport to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {HttpTransportType} transportType The specific transport to use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, transportType: HttpTransportType): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {IHttpConnectionOptions} options An options object used to configure the connection.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, options: IHttpConnectionOptions): HubConnectionBuilder;\r\n    public withUrl(url: string, transportTypeOrOptions?: IHttpConnectionOptions | HttpTransportType): HubConnectionBuilder {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n\r\n        this.url = url;\r\n\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        } else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    public withHubProtocol(protocol: IHubProtocol): HubConnectionBuilder {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     * By default, the client will wait 0, 2, 10 and 30 seconds respectively before trying up to 4 reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {number[]} retryDelays An array containing the delays in milliseconds before trying each reconnect attempt.\r\n     * The length of the array represents how many failed reconnect attempts it takes before the client will stop attempting to reconnect.\r\n     */\r\n    public withAutomaticReconnect(retryDelays: number[]): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {IRetryPolicy} reconnectPolicy An {@link @microsoft/signalR.IRetryPolicy} that controls the timing and number of reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(reconnectPolicy: IRetryPolicy): HubConnectionBuilder;\r\n    public withAutomaticReconnect(retryDelaysOrReconnectPolicy?: number[] | IRetryPolicy): HubConnectionBuilder {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        } else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    public build(): HubConnection {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n\r\n        return HubConnection.create(\r\n            connection,\r\n            this.logger || NullLogger.instance,\r\n            this.protocol || new JsonHubProtocol(),\r\n            this.reconnectPolicy);\r\n    }\r\n}\r\n\r\nfunction isLogger(logger: any): logger is ILogger {\r\n    return logger.log !== undefined;\r\n}\r\n","import { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport type { AudioActivityEvent } from \"./audio/AudioActivityEvent\";\r\nimport type { AudioSource } from \"./audio/AudioSource\";\r\nimport type { InterpolatedPose } from \"./audio/positions/InterpolatedPose\";\r\n\r\nexport type CallaTeleconferenceEventType = \"serverConnected\"\r\n    | \"serverDisconnected\"\r\n    | \"serverFailed\"\r\n    | \"conferenceConnected\"\r\n    | \"conferenceJoined\"\r\n    | \"conferenceFailed\"\r\n    | \"conferenceRestored\"\r\n    | \"conferenceLeft\"\r\n    | \"participantJoined\"\r\n    | \"participantLeft\"\r\n    | \"userNameChanged\"\r\n    | \"audioMuteStatusChanged\"\r\n    | \"videoMuteStatusChanged\"\r\n    | \"audioActivity\"\r\n    | \"audioAdded\"\r\n    | \"audioRemoved\"\r\n    | \"videoAdded\"\r\n    | \"videoRemoved\";\r\n\r\nexport type CallaMetadataEventType = \"userPosed\"\r\n    | \"userPointer\"\r\n    | \"setAvatarEmoji\"\r\n    | \"avatarChanged\"\r\n    | \"emote\"\r\n    | \"chat\";\r\n\r\nexport type CallaEventType = CallaTeleconferenceEventType | CallaMetadataEventType;\r\n\r\nexport class CallaEvent<T extends CallaEventType> extends Event {\r\n    constructor(public eventType: T) {\r\n        super(eventType);\r\n    }\r\n}\r\n\r\nexport class CallaTeleconferenceServerConnectedEvent\r\n    extends CallaEvent<\"serverConnected\"> {\r\n    constructor() {\r\n        super(\"serverConnected\");\r\n    }\r\n}\r\n\r\nexport class CallaTeleconferenceServerDisconnectedEvent\r\n    extends CallaEvent<\"serverDisconnected\"> {\r\n    constructor() {\r\n        super(\"serverDisconnected\");\r\n    }\r\n}\r\n\r\nexport class CallaTeleconferenceServerFailedEvent\r\n    extends CallaEvent<\"serverFailed\"> {\r\n    constructor() {\r\n        super(\"serverFailed\");\r\n    }\r\n}\r\n\r\nexport class CallaUserEvent<T extends CallaEventType> extends CallaEvent<T> {\r\n    constructor(type: T, public id: string) {\r\n        super(type);\r\n    }\r\n}\r\n\r\nexport class CallaParticipantEvent<T extends CallaTeleconferenceEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, id: string, public displayName: string) {\r\n        super(type, id);\r\n    }\r\n}\r\n\r\nexport class CallaUserNameChangedEvent extends CallaUserEvent<\"userNameChanged\"> {\r\n    constructor(id: string, public displayName: string) {\r\n        super(\"userNameChanged\", id);\r\n    }\r\n}\r\n\r\nexport class CallaConferenceJoinedEvent extends CallaUserEvent<\"conferenceJoined\"> {\r\n    constructor(id: string, public pose: InterpolatedPose) {\r\n        super(\"conferenceJoined\", id);\r\n    }\r\n}\r\n\r\nexport class CallaConferenceLeftEvent extends CallaUserEvent<\"conferenceLeft\"> {\r\n    constructor(id: string) {\r\n        super(\"conferenceLeft\", id);\r\n    }\r\n}\r\n\r\nexport class CallaConferenceConnectedEvent extends CallaEvent<\"conferenceConnected\"> {\r\n    constructor() {\r\n        super(\"conferenceConnected\");\r\n    }\r\n}\r\n\r\nexport class CallaConferenceFailedEvent extends CallaEvent<\"conferenceFailed\">{\r\n    constructor() {\r\n        super(\"conferenceFailed\");\r\n    }\r\n}\r\n\r\nexport class CallaConferenceRestoredEvent extends CallaEvent<\"conferenceRestored\">{\r\n    constructor() {\r\n        super(\"conferenceRestored\");\r\n    }\r\n}\r\n\r\nexport class CallaParticipantJoinedEvent extends CallaParticipantEvent<\"participantJoined\"> {\r\n    constructor(id: string, displayName: string, public source: AudioSource) {\r\n        super(\"participantJoined\", id, displayName);\r\n    }\r\n}\r\n\r\nexport class CallaParticipantLeftEvent extends CallaUserEvent<\"participantLeft\"> {\r\n    constructor(id: string) {\r\n        super(\"participantLeft\", id);\r\n    }\r\n}\r\n\r\nexport class CallaParticipantNameChangeEvent extends CallaParticipantEvent<\"userNameChanged\"> {\r\n    constructor(id: string, displayName: string) {\r\n        super(\"userNameChanged\", id, displayName);\r\n    }\r\n}\r\n\r\nexport class CallaUserMutedEvent<T extends CallaTeleconferenceEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, id: string, public muted: boolean) {\r\n        super(type, id);\r\n    }\r\n}\r\n\r\nexport class CallaUserAudioMutedEvent extends CallaUserMutedEvent<\"audioMuteStatusChanged\"> {\r\n    constructor(id: string, muted: boolean) {\r\n        super(\"audioMuteStatusChanged\", id, muted);\r\n    }\r\n}\r\n\r\nexport class CallaUserVideoMutedEvent extends CallaUserMutedEvent<\"videoMuteStatusChanged\"> {\r\n    constructor(id: string, muted: boolean) {\r\n        super(\"videoMuteStatusChanged\", id, muted);\r\n    }\r\n}\r\n\r\nexport enum StreamType {\r\n    Audio = \"audio\",\r\n    Video = \"video\"\r\n}\r\n\r\nexport enum StreamOpType {\r\n    Added = \"added\",\r\n    Removed = \"removed\",\r\n    Changed = \"changed\"\r\n}\r\n\r\nexport class CallaStreamEvent<T extends CallaTeleconferenceEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, public kind: StreamType, public op: StreamOpType, id: string, public stream: MediaStream) {\r\n        super(type, id);\r\n    }\r\n}\r\n\r\nexport class CallaStreamAddedEvent<T extends CallaTeleconferenceEventType> extends CallaStreamEvent<T> {\r\n    constructor(type: T, kind: StreamType, id: string, stream: MediaStream) {\r\n        super(type, kind, StreamOpType.Added, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaStreamRemovedEvent<T extends CallaTeleconferenceEventType> extends CallaStreamEvent<T> {\r\n    constructor(type: T, kind: StreamType, id: string, stream: MediaStream) {\r\n        super(type, kind, StreamOpType.Removed, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaStreamChangedEvent<T extends CallaTeleconferenceEventType> extends CallaStreamEvent<T> {\r\n    constructor(type: T, kind: StreamType, id: string, stream: MediaStream) {\r\n        super(type, kind, StreamOpType.Changed, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaAudioStreamAddedEvent extends CallaStreamAddedEvent<\"audioAdded\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"audioAdded\", StreamType.Audio, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaAudioStreamRemovedEvent extends CallaStreamRemovedEvent<\"audioRemoved\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"audioRemoved\", StreamType.Audio, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaVideoStreamAddedEvent extends CallaStreamAddedEvent<\"videoAdded\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"videoAdded\", StreamType.Video, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaVideoStreamRemovedEvent extends CallaStreamRemovedEvent<\"videoRemoved\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"videoRemoved\", StreamType.Video, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaPoseEvent<T extends CallaMetadataEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, id: string, public px: number, public py: number, public pz: number, public fx: number, public fy: number, public fz: number, public ux: number, public uy: number, public uz: number) {\r\n        super(type, id);\r\n    }\r\n\r\n    set(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) {\r\n        this.px = px;\r\n        this.py = py;\r\n        this.pz = pz;\r\n        this.fx = fx;\r\n        this.fy = fy;\r\n        this.fz = fz;\r\n        this.ux = ux;\r\n        this.uy = uy;\r\n        this.uz = uz;\r\n    }\r\n}\r\n\r\nexport class CallaUserPosedEvent extends CallaPoseEvent<\"userPosed\"> {\r\n    constructor(id: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) {\r\n        super(\"userPosed\", id, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n}\r\n\r\nexport class CallaUserPointerEvent extends CallaPoseEvent<\"userPointer\"> {\r\n    constructor(id: string, public name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) {\r\n        super(\"userPointer\", id, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n}\r\n\r\nexport class CallaEmojiEvent<T extends CallaMetadataEventType> extends CallaUserEvent<T> {\r\n    emoji: string;\r\n    constructor(type: T, id: string, emoji: Emoji | string) {\r\n        super(type, id);\r\n        if (emoji instanceof Emoji) {\r\n            this.emoji = emoji.value;\r\n        }\r\n        else {\r\n            this.emoji = emoji;\r\n        }\r\n    }\r\n}\r\n\r\nexport class CallaEmoteEvent extends CallaEmojiEvent<\"emote\"> {\r\n    constructor(id: string, emoji: Emoji | string) {\r\n        super(\"emote\", id, emoji);\r\n    }\r\n}\r\n\r\nexport class CallaEmojiAvatarEvent extends CallaEmojiEvent<\"setAvatarEmoji\"> {\r\n    constructor(id: string, emoji: Emoji | string) {\r\n        super(\"setAvatarEmoji\", id, emoji);\r\n    }\r\n}\r\n\r\nexport class CallaAvatarChangedEvent extends CallaUserEvent<\"avatarChanged\"> {\r\n    constructor(id: string, public url: string) {\r\n        super(\"avatarChanged\", id);\r\n    }\r\n}\r\n\r\nexport class CallaChatEvent extends CallaUserEvent<\"chat\"> {\r\n    constructor(id: string, public text: string) {\r\n        super(\"chat\", id);\r\n    }\r\n}\r\n\r\nexport interface CallaTeleconferenceEvents {\r\n    serverConnected: CallaTeleconferenceServerConnectedEvent;\r\n    serverDisconnected: CallaTeleconferenceServerDisconnectedEvent;\r\n    serverFailed: CallaTeleconferenceServerFailedEvent;\r\n    audioMuteStatusChanged: CallaUserAudioMutedEvent;\r\n    videoMuteStatusChanged: CallaUserVideoMutedEvent;\r\n    conferenceConnected: CallaConferenceConnectedEvent;\r\n    conferenceJoined: CallaConferenceJoinedEvent;\r\n    conferenceLeft: CallaConferenceLeftEvent;\r\n    conferenceFailed: CallaConferenceFailedEvent;\r\n    conferenceRestored: CallaConferenceRestoredEvent;\r\n    participantJoined: CallaParticipantJoinedEvent;\r\n    participantLeft: CallaParticipantLeftEvent;\r\n    userNameChanged: CallaUserNameChangedEvent;\r\n    audioActivity: AudioActivityEvent;\r\n    audioAdded: CallaAudioStreamAddedEvent;\r\n    videoAdded: CallaVideoStreamAddedEvent;\r\n    audioRemoved: CallaAudioStreamRemovedEvent;\r\n    videoRemoved: CallaVideoStreamRemovedEvent;\r\n}\r\n\r\nexport interface CallaMetadataEvents {\r\n    userPosed: CallaUserPosedEvent;\r\n    userPointer: CallaUserPointerEvent;\r\n    emote: CallaEmoteEvent;\r\n    setAvatarEmoji: CallaEmojiAvatarEvent;\r\n    avatarChanged: CallaAvatarChangedEvent;\r\n    chat: CallaChatEvent;\r\n}\r\n\r\nexport interface CallaClientEvents extends CallaTeleconferenceEvents, CallaMetadataEvents { }","export enum ConnectionState {\r\n    Disconnected = \"Disconnected\",\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnecting = \"Disconnecting\"\r\n}","﻿export function waitFor(test: () => boolean): Promise<void> {\r\n    return new Promise((resolve: () => void) => {\r\n        const handle = setInterval(() => {\r\n            if (test()) {\r\n                clearInterval(handle);\r\n                resolve();\r\n            }\r\n        }, 100);\r\n    });\r\n}\r\n","/**\r\n * Unicode-standardized pictograms.\r\n **/\r\nexport class Emoji {\r\n    props: any;\r\n\r\n    /**\r\n     * Creates a new Unicode-standardized pictograms.\r\n     * @param value - a Unicode sequence.\r\n     * @param desc - an English text description of the pictogram.\r\n     * @param props - an optional set of properties to store with the emoji.\r\n     */\r\n    constructor(public value: string, public desc: string, props: any = null) {\r\n        this.value = value;\r\n        this.desc = desc;\r\n        this.props = props || {};\r\n    }\r\n\r\n    /**\r\n     * Determines of the provided Emoji or EmojiGroup is a subset of\r\n     * this emoji.\r\n     */\r\n    contains(e: Emoji | string): boolean {\r\n        if (e instanceof Emoji) {\r\n            return this.contains(e.value);\r\n        }\r\n        else {\r\n            return this.value.indexOf(e) >= 0;\r\n        }\r\n    }\r\n}\r\n","import { arrayRemoveAt } from \"../arrays/arrayRemoveAt\";\r\nimport { isFunction } from \"../typeChecks\";\r\n\r\nexport class EventBase implements EventTarget {\r\n    private listeners = new Map<string, Function[]>();\r\n    private listenerOptions = new Map<Function, AddEventListenerOptions>();\r\n\r\n    addEventListener(type: string, callback: (evt: Event) => any, options?: AddEventListenerOptions): void {\r\n        if (isFunction(callback)) {\r\n            let listeners = this.listeners.get(type);\r\n            if (!listeners) {\r\n                listeners = new Array<Function>();\r\n                this.listeners.set(type, listeners);\r\n            }\r\n\r\n            if (!listeners.find(c => c === callback)) {\r\n                listeners.push(callback);\r\n\r\n                if (options) {\r\n                    this.listenerOptions.set(callback, options);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (evt: Event) => any) {\r\n        if (isFunction(callback)) {\r\n            const listeners = this.listeners.get(type);\r\n            if (listeners) {\r\n                this.removeListener(listeners, callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeListener(listeners: Function[], callback: Function) {\r\n        const idx = listeners.findIndex(c => c === callback);\r\n        if (idx >= 0) {\r\n            arrayRemoveAt(listeners, idx);\r\n            if (this.listenerOptions.has(callback)) {\r\n                this.listenerOptions.delete(callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(evt: Event): boolean {\r\n        const listeners = this.listeners.get(evt.type);\r\n        if (listeners) {\r\n            for (const callback of listeners) {\r\n                const options = this.listenerOptions.get(callback);\r\n                if (options && options.once) {\r\n                    this.removeListener(listeners, callback);\r\n                }\r\n\r\n                callback.call(this, evt);\r\n            }\r\n        }\r\n        return !evt.defaultPrevented;\r\n    }\r\n}\r\n\r\nexport class TypedEvent<T extends string> extends Event {\r\n    constructor(type: T) {\r\n        super(type);\r\n    }\r\n}\r\n\r\nexport class TypedEventBase<EventsT> extends EventBase {\r\n    private mappedCallbacks = new Map<Function, (evt: Event) => any>();\r\n\r\n    addEventListener<K extends string & keyof EventsT>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any, options?: AddEventListenerOptions): void {\r\n        let mappedCallback = this.mappedCallbacks.get(callback);\r\n        if (mappedCallback == null) {\r\n            mappedCallback = (evt: Event) => callback(evt as TypedEvent<K> & EventsT[K]);\r\n            this.mappedCallbacks.set(callback, mappedCallback);\r\n        }\r\n\r\n        super.addEventListener(type, mappedCallback, options);\r\n    }\r\n\r\n    removeEventListener<K extends string & keyof EventsT>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any) {\r\n        const mappedCallback = this.mappedCallbacks.get(callback);\r\n        if (mappedCallback) {\r\n            super.removeEventListener(type, mappedCallback);\r\n        }\r\n    }\r\n}","/**\r\n * Removes an item at the given index from an array.\r\n */\r\nexport function arrayRemoveAt<T>(arr: T[], idx: number) {\r\n    return arr.splice(idx, 1)[0];\r\n}","import type { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport { TypedEventBase } from \"kudzu/events/EventBase\";\r\nimport { sleep } from \"kudzu/events/sleep\";\r\nimport type { CallaEventType, CallaMetadataEvents } from \"../CallaEvents\";\r\nimport { CallaUserEvent } from \"../CallaEvents\";\r\nimport { ConnectionState } from \"../ConnectionState\";\r\nimport type { IMetadataClientExt } from \"./IMetadataClient\";\r\n\r\n\r\nexport abstract class BaseMetadataClient\r\n    extends TypedEventBase<CallaMetadataEvents>\r\n    implements IMetadataClientExt {\r\n\r\n    private tasks = new Map<string, Promise<any>>();\r\n\r\n    constructor(private sleepTime: number) {\r\n        super();\r\n    }\r\n\r\n    async getNext<T extends keyof CallaMetadataEvents>(evtName: T, userID: string): Promise<CallaMetadataEvents[T]> {\r\n        return new Promise((resolve) => {\r\n            const getter = (evt: CallaMetadataEvents[T]) => {\r\n                if (evt instanceof CallaUserEvent\r\n                    && evt.id === userID) {\r\n                    this.removeEventListener(evtName, getter);\r\n                    resolve(evt);\r\n                }\r\n            };\r\n\r\n            this.addEventListener(evtName, getter);\r\n        });\r\n    }\r\n\r\n    abstract get metadataState(): ConnectionState;\r\n\r\n    get isConnected(): boolean {\r\n        return this.metadataState === ConnectionState.Connected;\r\n    }\r\n\r\n    protected abstract callInternal(command: CallaEventType, ...args: any[]): Promise<void>;\r\n\r\n    private async callThrottled(key: string, command: CallaEventType, ...args: any[]): Promise<void> {\r\n        if (!this.tasks.has(key)) {\r\n            const start = performance.now();\r\n            const task = this.callInternal(command, ...args);\r\n            this.tasks.set(key, task);\r\n            await task;\r\n            const delta = performance.now() - start;\r\n            const sleepTime = this.sleepTime - delta;\r\n            if (sleepTime > 0) {\r\n                await sleep(this.sleepTime);\r\n            }\r\n            this.tasks.delete(key);\r\n        }\r\n    }\r\n\r\n    private async callImmediate(command: CallaEventType, ...args: any[]): Promise<void> {\r\n        await this.callInternal(command, ...args);\r\n    }\r\n\r\n    setLocalPose(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.callThrottled(\"userPosed\", \"userPosed\", px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPoseImmediate(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.callImmediate(\"userPosed\", px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPointer(name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.callThrottled(\"userPointer\" + name, \"userPointer\", name, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setAvatarEmoji(emoji: Emoji): void {\r\n        this.callImmediate(\"setAvatarEmoji\", emoji);\r\n    }\r\n\r\n    setAvatarURL(url: string): void {\r\n        this.callImmediate(\"avatarChanged\", url);\r\n    }\r\n\r\n    emote(emoji: Emoji): void {\r\n        this.callImmediate(\"emote\", emoji);\r\n    }\r\n\r\n    chat(text: string): void {\r\n        this.callImmediate(\"chat\", text);\r\n    }\r\n\r\n    abstract connect(): Promise<void>;\r\n    abstract join(roomName: string): Promise<void>;\r\n    abstract identify(userNameOrID: string): Promise<void>;\r\n    abstract leave(): Promise<void>;\r\n    abstract disconnect(): Promise<void>;\r\n}\r\n","export function sleep(dt: number) : Promise<void> {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, dt);\r\n    });\r\n}\r\n","/**\r\n * Scans through a series of filters to find an item that matches\r\n * any of the filters. The first item of the first filter that matches\r\n * will be returned.\r\n */\r\nexport function arrayScan<T>(arr: T[], ...tests: ((val: T) => boolean)[]) {\r\n    for (const test of tests) {\r\n        for (const item of arr) {\r\n            if (test(item)) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}","import { arrayScan } from \"kudzu/arrays/arrayScan\";\r\nimport type { ErsatzEventTarget } from \"kudzu/events/ErsatzEventTarget\";\r\nimport { TypedEventBase } from \"kudzu/events/EventBase\";\r\nimport { IFetcher } from \"kudzu/io/IFetcher\";\r\nimport { AudioManager } from \"../audio/AudioManager\";\r\nimport { canChangeAudioOutput } from \"../audio/canChangeAudioOutput\";\r\nimport type { MediaDeviceSet, MediaPermissionSet } from \"../Calla\";\r\nimport type { CallaTeleconferenceEvents } from \"../CallaEvents\";\r\nimport { CallaUserEvent } from \"../CallaEvents\";\r\nimport { ConnectionState } from \"../ConnectionState\";\r\nimport type { IMetadataClientExt } from \"../meta/IMetadataClient\";\r\nimport type { ITeleconferenceClientExt } from \"./ITeleconferenceClient\";\r\n\r\nexport function addLogger(obj: ErsatzEventTarget, evtName: string): void {\r\n    obj.addEventListener(evtName, (...rest: any[]) => {\r\n        if (loggingEnabled) {\r\n            console.log(\">== CALLA ==<\", evtName, ...rest);\r\n        }\r\n    });\r\n}\r\n\r\n\r\nfunction filterDeviceDuplicates(devices: MediaDeviceInfo[]) {\r\n    const filtered = [];\r\n    for (let i = 0; i < devices.length; ++i) {\r\n        const a = devices[i];\r\n        let found = false;\r\n        for (let j = 0; j < filtered.length && !found; ++j) {\r\n            const b = filtered[j];\r\n            found = a.kind === b.kind && b.label.indexOf(a.label) > 0;\r\n        }\r\n\r\n        if (!found) {\r\n            filtered.push(a);\r\n        }\r\n    }\r\n\r\n    return filtered;\r\n}\r\n\r\nconst PREFERRED_AUDIO_OUTPUT_ID_KEY = \"calla:preferredAudioOutputID\";\r\nconst PREFERRED_AUDIO_INPUT_ID_KEY = \"calla:preferredAudioInputID\";\r\nconst PREFERRED_VIDEO_INPUT_ID_KEY = \"calla:preferredVideoInputID\";\r\n\r\nexport const DEFAULT_LOCAL_USER_ID = \"local-user\";\r\n\r\nlet loggingEnabled = window.location.hostname === \"localhost\"\r\n    || /\\bdebug\\b/.test(window.location.search);\r\n\r\nexport abstract class BaseTeleconferenceClient\r\n    extends TypedEventBase<CallaTeleconferenceEvents>\r\n    implements ITeleconferenceClientExt {\r\n\r\n    toggleLogging() {\r\n        loggingEnabled = !loggingEnabled;\r\n    }\r\n\r\n    localUserID: string = null;\r\n    localUserName: string = null;\r\n    roomName: string = null;\r\n\r\n    protected fetcher: IFetcher;\r\n\r\n    audio: AudioManager;\r\n\r\n    private _connectionState = ConnectionState.Disconnected;\r\n    private _conferenceState = ConnectionState.Disconnected;\r\n\r\n    hasAudioPermission = false;\r\n    hasVideoPermission = false;\r\n\r\n    get connectionState(): ConnectionState {\r\n        return this._connectionState;\r\n    }\r\n\r\n    private setConnectionState(state: ConnectionState): void {\r\n        this._connectionState = state;\r\n    }\r\n\r\n    get conferenceState(): ConnectionState {\r\n        return this._conferenceState;\r\n    }\r\n\r\n    private setConferenceState(state: ConnectionState): void {\r\n        this._conferenceState = state;\r\n    }\r\n\r\n    constructor(fetcher: IFetcher, audio: AudioManager, public needsAudioDevice = true, public needsVideoDevice = false) {\r\n        super();\r\n\r\n        this.fetcher = fetcher;\r\n\r\n        this.audio = audio;\r\n\r\n        this.addEventListener(\"serverConnected\", this.setConnectionState.bind(this, ConnectionState.Connected));\r\n        this.addEventListener(\"serverFailed\", this.setConnectionState.bind(this, ConnectionState.Disconnected));\r\n        this.addEventListener(\"serverDisconnected\", this.setConnectionState.bind(this, ConnectionState.Disconnected));\r\n\r\n        this.addEventListener(\"conferenceJoined\", this.setConferenceState.bind(this, ConnectionState.Connected));\r\n        this.addEventListener(\"conferenceFailed\", this.setConferenceState.bind(this, ConnectionState.Disconnected));\r\n        this.addEventListener(\"conferenceRestored\", this.setConferenceState.bind(this, ConnectionState.Connected));\r\n        this.addEventListener(\"conferenceLeft\", this.setConferenceState.bind(this, ConnectionState.Disconnected));\r\n    }\r\n\r\n    dispatchEvent<K extends string & keyof CallaTeleconferenceEvents>(evt: CallaTeleconferenceEvents[K] & Event): boolean {\r\n        if (evt instanceof CallaUserEvent\r\n            && (evt.id == null\r\n                || evt.id === \"local\")) {\r\n            if (this.localUserID === DEFAULT_LOCAL_USER_ID) {\r\n                evt.id = null;\r\n            }\r\n            else {\r\n                evt.id = this.localUserID;\r\n            }\r\n        }\r\n\r\n        return super.dispatchEvent(evt);\r\n    }\r\n\r\n    async getNext<T extends keyof CallaTeleconferenceEvents>(evtName: T, userID: string): Promise<CallaTeleconferenceEvents[T]> {\r\n        return new Promise((resolve) => {\r\n            const getter = (evt: CallaTeleconferenceEvents[T]) => {\r\n                if (evt instanceof CallaUserEvent\r\n                    && evt.id === userID) {\r\n                    this.removeEventListener(evtName, getter);\r\n                    resolve(evt);\r\n                }\r\n            };\r\n\r\n            this.addEventListener(evtName, getter);\r\n        });\r\n    }\r\n\r\n\r\n\r\n    get preferredAudioInputID(): string {\r\n        return localStorage.getItem(PREFERRED_AUDIO_INPUT_ID_KEY);\r\n    }\r\n\r\n    set preferredAudioInputID(v: string) {\r\n        localStorage.setItem(PREFERRED_AUDIO_INPUT_ID_KEY, v);\r\n    }\r\n\r\n    get preferredVideoInputID(): string {\r\n        return localStorage.getItem(PREFERRED_VIDEO_INPUT_ID_KEY);\r\n    }\r\n\r\n    set preferredVideoInputID(v: string) {\r\n        localStorage.setItem(PREFERRED_VIDEO_INPUT_ID_KEY, v);\r\n    }\r\n\r\n    async setPreferredDevices(): Promise<void> {\r\n        await this.setPreferredAudioInput(true);\r\n        await this.setPreferredVideoInput(false);\r\n        await this.setPreferredAudioOutput(true);\r\n    }\r\n\r\n    async getPreferredAudioInput(allowAny: boolean): Promise<MediaDeviceInfo> {\r\n        const devices = await this.getAudioInputDevices();\r\n        const device = arrayScan(\r\n            devices,\r\n            (d) => d.deviceId === this.preferredAudioInputID,\r\n            (d) => d.deviceId === \"communications\",\r\n            (d) => d.deviceId === \"default\",\r\n            (d) => allowAny && d.deviceId.length > 0);\r\n        return device;\r\n    }\r\n\r\n    async setPreferredAudioInput(allowAny: boolean): Promise<void> {\r\n        const device = await this.getPreferredAudioInput(allowAny);\r\n        if (device) {\r\n            await this.setAudioInputDevice(device);\r\n        }\r\n    }\r\n\r\n    async getPreferredVideoInput(allowAny: boolean): Promise<MediaDeviceInfo> {\r\n        const devices = await this.getVideoInputDevices();\r\n        const device = arrayScan(devices,\r\n            (d) => d.deviceId === this.preferredVideoInputID,\r\n            (d) => allowAny && d && /front/i.test(d.label),\r\n            (d) => allowAny && d.deviceId.length > 0);\r\n        return device;\r\n    }\r\n\r\n    async setPreferredVideoInput(allowAny: boolean): Promise<void> {\r\n        const device = await this.getPreferredVideoInput(allowAny);\r\n        if (device) {\r\n            await this.setVideoInputDevice(device);\r\n        }\r\n    }\r\n\r\n    private async getDevices(): Promise<MediaDeviceInfo[]> {\r\n        let devices: MediaDeviceInfo[] = null;\r\n        for (let i = 0; i < 3; ++i) {\r\n            devices = await navigator.mediaDevices.enumerateDevices();\r\n            for (const device of devices) {\r\n                if (device.deviceId.length > 0) {\r\n                    this.hasAudioPermission = this.hasAudioPermission || device.kind === \"audioinput\" && device.label.length > 0;\r\n                    this.hasVideoPermission = this.hasVideoPermission || device.kind === \"videoinput\" && device.label.length > 0;\r\n                }\r\n            }\r\n\r\n            if (this.hasAudioPermission) {\r\n                break;\r\n            }\r\n\r\n            try {\r\n                await navigator.mediaDevices.getUserMedia({\r\n                    audio: this.needsAudioDevice && !this.hasAudioPermission,\r\n                    video: this.needsVideoDevice && !this.hasVideoPermission\r\n                });\r\n            }\r\n            catch (exp) {\r\n                console.warn(exp);\r\n            }\r\n        }\r\n\r\n        return devices || [];\r\n    }\r\n\r\n    async getMediaPermissions(): Promise<MediaPermissionSet> {\r\n        await this.getDevices();\r\n        return {\r\n            audio: this.hasAudioPermission,\r\n            video: this.hasVideoPermission\r\n        };\r\n    }\r\n\r\n    private async getAvailableDevices(filterDuplicates: boolean = false): Promise<MediaDeviceSet> {\r\n        let devices = await this.getDevices();\r\n\r\n        if (filterDuplicates) {\r\n            devices = filterDeviceDuplicates(devices);\r\n        }\r\n\r\n        return {\r\n            audioOutput: canChangeAudioOutput ? devices.filter(d => d.kind === \"audiooutput\") : [],\r\n            audioInput: devices.filter(d => d.kind === \"audioinput\"),\r\n            videoInput: devices.filter(d => d.kind === \"videoinput\")\r\n        };\r\n    }\r\n\r\n    async getAudioInputDevices(filterDuplicates: boolean = false): Promise<MediaDeviceInfo[]> {\r\n        const devices = await this.getAvailableDevices(filterDuplicates);\r\n        return devices && devices.audioInput || [];\r\n    }\r\n\r\n    async getVideoInputDevices(filterDuplicates: boolean = false): Promise<MediaDeviceInfo[]> {\r\n        const devices = await this.getAvailableDevices(filterDuplicates);\r\n        return devices && devices.videoInput || [];\r\n    }\r\n\r\n    async setAudioOutputDevice(device: MediaDeviceInfo) {\r\n        if (canChangeAudioOutput) {\r\n            this.preferredAudioOutputID = device && device.deviceId || null;\r\n        }\r\n    }\r\n\r\n    async getAudioOutputDevices(filterDuplicates: boolean = false): Promise<MediaDeviceInfo[]> {\r\n        if (!canChangeAudioOutput) {\r\n            return [];\r\n        }\r\n        const devices = await this.getAvailableDevices(filterDuplicates);\r\n        return devices && devices.audioOutput || [];\r\n    }\r\n\r\n    async getCurrentAudioOutputDevice() {\r\n        if (!canChangeAudioOutput) {\r\n            return null;\r\n        }\r\n        const curId = this.audio.getAudioOutputDeviceID(),\r\n            devices = await this.getAudioOutputDevices(),\r\n            device = devices.filter((d) => curId != null && d.deviceId === curId\r\n                || curId == null && d.deviceId === this.preferredAudioOutputID);\r\n        if (device.length === 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return device[0];\r\n        }\r\n    }\r\n\r\n    get preferredAudioOutputID(): string {\r\n        return localStorage.getItem(PREFERRED_AUDIO_OUTPUT_ID_KEY);\r\n    }\r\n\r\n    set preferredAudioOutputID(v: string) {\r\n        localStorage.setItem(PREFERRED_AUDIO_OUTPUT_ID_KEY, v);\r\n    }\r\n\r\n\r\n    async getPreferredAudioOutput(allowAny: boolean): Promise<MediaDeviceInfo> {\r\n        const devices = await this.getAudioOutputDevices();\r\n        const device = arrayScan(\r\n            devices,\r\n            (d) => d.deviceId === this.preferredAudioOutputID,\r\n            (d) => d.deviceId === \"communications\",\r\n            (d) => d.deviceId === \"default\",\r\n            (d) => allowAny && d.deviceId.length > 0);\r\n        return device;\r\n    }\r\n\r\n    async setPreferredAudioOutput(allowAny: boolean): Promise<void> {\r\n        const device = await this.getPreferredAudioOutput(allowAny);\r\n        if (device) {\r\n            await this.setAudioOutputDevice(device);\r\n        }\r\n    }\r\n\r\n    async setAudioInputDevice(device: MediaDeviceInfo): Promise<void> {\r\n        this.preferredAudioInputID = device && device.deviceId || null;\r\n    }\r\n\r\n    async setVideoInputDevice(device: MediaDeviceInfo) {\r\n        this.preferredVideoInputID = device && device.deviceId || null;\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        this.setConnectionState(ConnectionState.Connecting);\r\n    }\r\n\r\n    async join(_roomName: string, _password?: string): Promise<void> {\r\n        this.setConferenceState(ConnectionState.Connecting);\r\n    }\r\n\r\n    async leave(): Promise<void> {\r\n        this.setConferenceState(ConnectionState.Disconnecting);\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        this.setConnectionState(ConnectionState.Disconnecting);\r\n    }\r\n\r\n    abstract userExists(id: string): boolean;\r\n    abstract getUserNames(): string[][];\r\n    abstract identify(userNameOrID: string): Promise<void>;\r\n    abstract getCurrentAudioInputDevice(): Promise<MediaDeviceInfo>;\r\n    abstract getCurrentVideoInputDevice(): Promise<MediaDeviceInfo>;\r\n    abstract toggleAudioMuted(): Promise<boolean>;\r\n    abstract toggleVideoMuted(): Promise<boolean>;\r\n    abstract getAudioMuted(): Promise<boolean>;\r\n    abstract getVideoMuted(): Promise<boolean>;\r\n    abstract getDefaultMetadataClient(): IMetadataClientExt;\r\n}\r\n","/**\r\n * An Event class for tracking changes to audio activity.\r\n **/\r\nexport class AudioActivityEvent extends Event {\r\n    id: string = null;\r\n    isActive: boolean = false;\r\n\r\n    /** Creates a new \"audioActivity\" event */\r\n    constructor() {\r\n        super(\"audioActivity\");\r\n        Object.seal(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the current state of the event\r\n     * @param id - the user for which the activity changed\r\n     * @param isActive - the new state of the activity\r\n     */\r\n    set(id: string, isActive: boolean): void {\r\n        this.id = id;\r\n        this.isActive = isActive;\r\n    }\r\n}\r\n","import type { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport { TypedEventBase } from \"kudzu/events/EventBase\";\r\nimport type { IFetcher } from \"kudzu/io/IFetcher\";\r\nimport type { IDisposable } from \"kudzu/using\";\r\nimport { AudioActivityEvent } from \"./audio/AudioActivityEvent\";\r\nimport type { AudioManager } from \"./audio/AudioManager\";\r\nimport { canChangeAudioOutput } from \"./audio/canChangeAudioOutput\";\r\nimport type {\r\n    CallaAudioStreamAddedEvent,\r\n    CallaAudioStreamRemovedEvent,\r\n    CallaClientEvents,\r\n    CallaConferenceJoinedEvent,\r\n    CallaConferenceLeftEvent,\r\n    CallaParticipantJoinedEvent,\r\n    CallaParticipantLeftEvent,\r\n    CallaUserPointerEvent,\r\n    CallaUserPosedEvent\r\n} from \"./CallaEvents\";\r\nimport { ConnectionState } from \"./ConnectionState\";\r\nimport type { ICombinedClient } from \"./ICombinedClient\";\r\nimport type { IMetadataClient, IMetadataClientExt } from \"./meta/IMetadataClient\";\r\nimport type { ITeleconferenceClient, ITeleconferenceClientExt } from \"./tele/ITeleconferenceClient\";\r\n\r\nexport interface MediaPermissionSet {\r\n    audio: boolean;\r\n    video: boolean;\r\n}\r\n\r\nexport interface MediaDeviceSet {\r\n    audioInput: MediaDeviceInfo[];\r\n    videoInput: MediaDeviceInfo[];\r\n    audioOutput: MediaDeviceInfo[];\r\n}\r\n\r\nexport enum ClientState {\r\n    InConference = \"in-conference\",\r\n    JoiningConference = \"joining-conference\",\r\n    Connected = \"connected\",\r\n    Connecting = \"connecting\",\r\n    Prepaired = \"prepaired\",\r\n    Prepairing = \"prepairing\",\r\n    Unprepared = \"unprepaired\"\r\n}\r\n\r\nconst audioActivityEvt = new AudioActivityEvent();\r\n\r\nexport class Calla\r\n    extends TypedEventBase<CallaClientEvents>\r\n    implements ICombinedClient, IDisposable {\r\n\r\n    isAudioMuted: boolean = null;\r\n    isVideoMuted: boolean = null;\r\n\r\n    constructor(\r\n        private _fetcher: IFetcher,\r\n        private _tele: ITeleconferenceClientExt,\r\n        private _meta: IMetadataClientExt) {\r\n        super();\r\n\r\n        const fwd = this.dispatchEvent.bind(this);\r\n\r\n        this._tele.addEventListener(\"serverConnected\", fwd);\r\n        this._tele.addEventListener(\"serverDisconnected\", fwd);\r\n        this._tele.addEventListener(\"serverFailed\", fwd);\r\n        this._tele.addEventListener(\"conferenceFailed\", fwd);\r\n        this._tele.addEventListener(\"conferenceRestored\", fwd);\r\n\r\n        this._tele.addEventListener(\"audioMuteStatusChanged\", fwd);\r\n        this._tele.addEventListener(\"videoMuteStatusChanged\", fwd);\r\n\r\n        this._tele.addEventListener(\"conferenceJoined\", async (evt: CallaConferenceJoinedEvent) => {\r\n            const user = this.audio.createLocalUser(evt.id);\r\n            evt.pose = user.pose;\r\n            this.dispatchEvent(evt);\r\n            await this.setPreferredDevices();\r\n        });\r\n\r\n        this._tele.addEventListener(\"conferenceLeft\", (evt: CallaConferenceLeftEvent) => {\r\n            this.audio.createLocalUser(evt.id);\r\n            this.dispatchEvent(evt);\r\n        });\r\n\r\n        this._tele.addEventListener(\"participantJoined\", async (joinEvt: CallaParticipantJoinedEvent) => {\r\n            joinEvt.source = this.audio.createUser(joinEvt.id);\r\n            this.dispatchEvent(joinEvt);\r\n        });\r\n\r\n        this._tele.addEventListener(\"participantLeft\", (evt: CallaParticipantLeftEvent) => {\r\n            this.dispatchEvent(evt);\r\n            this.audio.removeUser(evt.id);\r\n        });\r\n\r\n        this._tele.addEventListener(\"userNameChanged\", fwd);\r\n        this._tele.addEventListener(\"videoAdded\", fwd);\r\n        this._tele.addEventListener(\"videoRemoved\", fwd);\r\n\r\n        this._tele.addEventListener(\"audioAdded\", (evt: CallaAudioStreamAddedEvent) => {\r\n            const user = this.audio.getUser(evt.id);\r\n            if (user) {\r\n                let stream = user.streams.get(evt.kind);\r\n                if (stream) {\r\n                    user.streams.delete(evt.kind);\r\n                }\r\n\r\n                stream = evt.stream;\r\n                user.streams.set(evt.kind, stream);\r\n\r\n                if (evt.id !== this._tele.localUserID) {\r\n                    this.audio.setUserStream(evt.id, stream);\r\n                }\r\n\r\n                this.dispatchEvent(evt);\r\n            }\r\n        });\r\n\r\n        this._tele.addEventListener(\"audioRemoved\", (evt: CallaAudioStreamRemovedEvent) => {\r\n            const user = this.audio.getUser(evt.id);\r\n            if (user && user.streams.has(evt.kind)) {\r\n                user.streams.delete(evt.kind);\r\n            }\r\n\r\n            if (evt.id !== this._tele.localUserID) {\r\n                this.audio.setUserStream(evt.id, null);\r\n            }\r\n\r\n            this.dispatchEvent(evt);\r\n        });\r\n\r\n        this._meta.addEventListener(\"avatarChanged\", fwd);\r\n        this._meta.addEventListener(\"chat\", fwd);\r\n        this._meta.addEventListener(\"emote\", fwd);\r\n        this._meta.addEventListener(\"setAvatarEmoji\", fwd);\r\n\r\n        const offsetEvt = (poseEvt: CallaUserPointerEvent | CallaUserPosedEvent): void => {\r\n            const O = this.audio.getUserOffset(poseEvt.id);\r\n            if (O) {\r\n                poseEvt.px += O[0];\r\n                poseEvt.py += O[1];\r\n                poseEvt.pz += O[2];\r\n            }\r\n            this.dispatchEvent(poseEvt);\r\n        };\r\n\r\n        this._meta.addEventListener(\"userPointer\", offsetEvt);\r\n\r\n        this._meta.addEventListener(\"userPosed\", (evt: CallaUserPosedEvent) => {\r\n            this.audio.setUserPose(\r\n                evt.id,\r\n                evt.px, evt.py, evt.pz,\r\n                evt.fx, evt.fy, evt.fz,\r\n                evt.ux, evt.uy, evt.uz);\r\n            offsetEvt(evt);\r\n        });\r\n\r\n        this.audio.addEventListener(\"audioActivity\", (evt: AudioActivityEvent) => {\r\n            audioActivityEvt.id = evt.id;\r\n            audioActivityEvt.isActive = evt.isActive;\r\n            this.dispatchEvent(audioActivityEvt);\r\n        });\r\n\r\n        const dispose = this.dispose.bind(this);\r\n        window.addEventListener(\"beforeunload\", dispose);\r\n        window.addEventListener(\"unload\", dispose);\r\n        window.addEventListener(\"pagehide\", dispose);\r\n\r\n        Object.seal(this);\r\n    }\r\n\r\n    get connectionState(): ConnectionState {\r\n        return this._tele.connectionState;\r\n    }\r\n\r\n    get conferenceState(): ConnectionState {\r\n        return this._tele.conferenceState;\r\n    }\r\n\r\n    get fetcher(): IFetcher {\r\n        return this._fetcher;\r\n    }\r\n\r\n    get tele(): ITeleconferenceClient {\r\n        return this._tele;\r\n    }\r\n\r\n    get meta(): IMetadataClient {\r\n        return this._meta;\r\n    }\r\n\r\n    get audio(): AudioManager {\r\n        return this._tele.audio;\r\n    }\r\n\r\n    get preferredAudioOutputID(): string {\r\n        return this._tele.preferredAudioOutputID;\r\n    }\r\n\r\n    set preferredAudioOutputID(v: string) {\r\n        this._tele.preferredAudioOutputID = v;\r\n    }\r\n\r\n    get preferredAudioInputID(): string {\r\n        return this._tele.preferredAudioInputID;\r\n    }\r\n\r\n    set preferredAudioInputID(v: string) {\r\n        this._tele.preferredAudioInputID = v;\r\n    }\r\n\r\n    get preferredVideoInputID(): string {\r\n        return this._tele.preferredVideoInputID;\r\n    }\r\n\r\n    set preferredVideoInputID(v: string) {\r\n        this._tele.preferredVideoInputID = v;\r\n    }\r\n\r\n    async getCurrentAudioOutputDevice(): Promise<MediaDeviceInfo> {\r\n        return await this._tele.getCurrentAudioOutputDevice();\r\n    }\r\n\r\n    async getMediaPermissions(): Promise<MediaPermissionSet> {\r\n        return await this._tele.getMediaPermissions();\r\n    }\r\n\r\n    async getAudioOutputDevices(filterDuplicates: boolean): Promise<MediaDeviceInfo[]> {\r\n        return await this._tele.getAudioOutputDevices(filterDuplicates);\r\n    }\r\n\r\n    async getAudioInputDevices(filterDuplicates: boolean): Promise<MediaDeviceInfo[]> {\r\n        return await this._tele.getAudioInputDevices(filterDuplicates);\r\n    }\r\n\r\n    async getVideoInputDevices(filterDuplicates: boolean): Promise<MediaDeviceInfo[]> {\r\n        return await this._tele.getVideoInputDevices(filterDuplicates);\r\n    }\r\n\r\n    dispose(): void {\r\n        this.leave();\r\n        this.disconnect();\r\n    }\r\n\r\n    get offsetRadius(): number {\r\n        return this.audio.offsetRadius;\r\n    }\r\n\r\n    set offsetRadius(v: number) {\r\n        this.audio.offsetRadius = v;\r\n    }\r\n\r\n    setLocalPose(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.audio.setUserPose(this.localUserID, px, py, pz, fx, fy, fz, ux, uy, uz, 0);\r\n        this._meta.setLocalPose(px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPoseImmediate(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.audio.setUserPose(this.localUserID, px, py, pz, fx, fy, fz, ux, uy, uz, 0);\r\n        this._meta.setLocalPoseImmediate(px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPointer(name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this._meta.setLocalPointer(name, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setAvatarEmoji(emoji: Emoji): void {\r\n        this._meta.setAvatarEmoji(emoji);\r\n    }\r\n\r\n    setAvatarURL(url: string): void {\r\n        this._meta.setAvatarURL(url);\r\n    }\r\n\r\n    emote(emoji: Emoji): void {\r\n        this._meta.emote(emoji);\r\n    }\r\n\r\n    chat(text: string): void {\r\n        this._meta.chat(text);\r\n    }\r\n\r\n    async setPreferredDevices(): Promise<void> {\r\n        await this._tele.setPreferredDevices();\r\n    }\r\n\r\n    async setAudioInputDevice(device: MediaDeviceInfo): Promise<void> {\r\n        await this._tele.setAudioInputDevice(device);\r\n    }\r\n\r\n    async setVideoInputDevice(device: MediaDeviceInfo): Promise<void> {\r\n        await this._tele.setVideoInputDevice(device);\r\n    }\r\n\r\n    async getCurrentAudioInputDevice(): Promise<MediaDeviceInfo> {\r\n        return await this._tele.getCurrentAudioInputDevice();\r\n    }\r\n\r\n    async getCurrentVideoInputDevice(): Promise<MediaDeviceInfo> {\r\n        return await this._tele.getCurrentVideoInputDevice();\r\n    }\r\n\r\n    async toggleAudioMuted(): Promise<boolean> {\r\n        return await this._tele.toggleAudioMuted();\r\n    }\r\n\r\n    async toggleVideoMuted(): Promise<boolean> {\r\n        return await this._tele.toggleVideoMuted();\r\n    }\r\n\r\n    async getAudioMuted(): Promise<boolean> {\r\n        return await this._tele.getAudioMuted();\r\n    }\r\n\r\n    async getVideoMuted(): Promise<boolean> {\r\n        return await this._tele.getVideoMuted();\r\n    }\r\n\r\n    get metadataState(): ConnectionState {\r\n        return this._meta.metadataState;\r\n    }\r\n\r\n    get localUserID() {\r\n        return this._tele.localUserID;\r\n    }\r\n\r\n    get localUserName() {\r\n        return this._tele.localUserName;\r\n    }\r\n\r\n    get roomName() {\r\n        return this._tele.roomName;\r\n    }\r\n\r\n    userExists(id: string): boolean {\r\n        return this._tele.userExists(id);\r\n    }\r\n\r\n    getUserNames(): string[][] {\r\n        return this._tele.getUserNames();\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        await this._tele.connect();\r\n        if (this._tele.connectionState === ConnectionState.Connected) {\r\n            await this._meta.connect();\r\n        }\r\n    }\r\n\r\n    async join(roomName: string): Promise<void> {\r\n        await this._tele.join(roomName);\r\n        if (this._tele.conferenceState === ConnectionState.Connected) {\r\n            await this._meta.join(roomName);\r\n        }\r\n    }\r\n\r\n    async identify(userName: string): Promise<void> {\r\n        await this._tele.identify(userName);\r\n        await this._meta.identify(this.localUserID);\r\n    }\r\n\r\n    async leave(): Promise<void> {\r\n        await this._meta.leave();\r\n        await this._tele.leave();\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        await this._meta.disconnect();\r\n        await this._tele.disconnect();\r\n    }\r\n\r\n    update(): void {\r\n        this.audio.update();\r\n    }\r\n\r\n    async setAudioOutputDevice(device: MediaDeviceInfo) {\r\n        this._tele.setAudioOutputDevice(device);\r\n        if (canChangeAudioOutput) {\r\n            await this.audio.setAudioOutputDeviceID(this._tele.preferredAudioOutputID);\r\n        }\r\n    }\r\n\r\n    async setAudioMuted(muted: boolean) {\r\n        let isMuted = this.isAudioMuted;\r\n        if (muted !== isMuted) {\r\n            isMuted = await this.toggleAudioMuted();\r\n        }\r\n        return isMuted;\r\n    }\r\n\r\n    async setVideoMuted(muted: boolean) {\r\n        let isMuted = this.isVideoMuted;\r\n        if (muted !== isMuted) {\r\n            isMuted = await this.toggleVideoMuted();\r\n        }\r\n        return isMuted;\r\n    }\r\n\r\n}","export * from \"./audio/canChangeAudioOutput\";\r\nexport * from \"./meta/signalr/SignalRMetadataClient\";\r\nexport * from \"./meta/BaseMetadataClient\";\r\nexport * from \"./tele/BaseTeleconferenceClient\";\r\nexport { Calla as Client } from \"./Calla\";\r\nexport {\r\n    CallaTeleconferenceEventType as TeleconferenceEvents,\r\n    CallaMetadataEventType as MetadataEvents\r\n} from \"./CallaEvents\";\r\n\r\nimport { version } from \"./package.json\";\r\nconsole.info(`Calla v${version}.`);\r\n\r\nexport { version };","import {\r\n    HttpTransportType,\r\n    HubConnection,\r\n    HubConnectionBuilder, HubConnectionState\r\n} from \"@microsoft/signalr\";\r\nimport type { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport { waitFor } from \"kudzu/events/waitFor\";\r\nimport { assertNever } from \"kudzu/typeChecks\";\r\nimport type { CallaEventType } from \"../../CallaEvents\";\r\nimport {\r\n    CallaAvatarChangedEvent,\r\n    CallaChatEvent,\r\n    CallaEmojiAvatarEvent,\r\n    CallaEmoteEvent,\r\n    CallaUserPointerEvent,\r\n    CallaUserPosedEvent\r\n} from \"../../CallaEvents\";\r\nimport { ConnectionState } from \"../../ConnectionState\";\r\nimport { BaseMetadataClient } from \"../BaseMetadataClient\";\r\n\r\nexport class SignalRMetadataClient\r\n    extends BaseMetadataClient {\r\n\r\n    private hub: HubConnection;\r\n    private lastRoom: string = null;\r\n    private lastUserID: string = null;\r\n    private currentRoom: string = null;\r\n    private currentUserID: string = null;\r\n\r\n    constructor(signalRPath: string) {\r\n        super(50);\r\n\r\n        this.hub = new HubConnectionBuilder()\r\n            .withUrl(signalRPath, HttpTransportType.WebSockets)\r\n            .build();\r\n\r\n        this.hub.onclose(() => {\r\n            this.lastRoom = null;\r\n            this.lastUserID = null;\r\n        });\r\n\r\n        this.hub.on(\"userPosed\",\r\n            (fromUserID: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) => {\r\n                this.dispatchEvent(new CallaUserPosedEvent(fromUserID, px, py, pz, fx, fy, fz, ux, uy, uz));\r\n            });\r\n\r\n        this.hub.on(\"userPointer\",\r\n            (fromUserID: string, name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) => {\r\n                this.dispatchEvent(new CallaUserPointerEvent(fromUserID, name, px, py, pz, fx, fy, fz, ux, uy, uz));\r\n            });\r\n\r\n        this.hub.on(\"avatarChanged\",\r\n            (fromUserID: string, url: string) => {\r\n                this.dispatchEvent(new CallaAvatarChangedEvent(fromUserID, url));\r\n            });\r\n\r\n        this.hub.on(\"emote\",\r\n            (fromUserID: string, emoji: Emoji) => {\r\n                this.dispatchEvent(new CallaEmoteEvent(fromUserID, emoji));\r\n            });\r\n\r\n        this.hub.on(\"setAvatarEmoji\",\r\n            (fromUserID: string, emoji: Emoji) => {\r\n                this.dispatchEvent(new CallaEmojiAvatarEvent(fromUserID, emoji));\r\n            });\r\n\r\n        this.hub.on(\"chat\",\r\n            (fromUserID: string, text: string) => {\r\n                this.dispatchEvent(new CallaChatEvent(fromUserID, text));\r\n            });\r\n    }\r\n\r\n    get metadataState() {\r\n        switch (this.hub.state) {\r\n            case HubConnectionState.Connected: return ConnectionState.Connected;\r\n            case HubConnectionState.Connecting: case HubConnectionState.Reconnecting: return ConnectionState.Connecting;\r\n            case HubConnectionState.Disconnected: return ConnectionState.Disconnected;\r\n            case HubConnectionState.Disconnecting: return ConnectionState.Disconnecting;\r\n            default: assertNever(this.hub.state);\r\n        }\r\n    }\r\n\r\n    private async maybeStart(): Promise<void> {\r\n        if (this.metadataState === ConnectionState.Connecting) {\r\n            await waitFor(() => this.metadataState === ConnectionState.Connected);\r\n        }\r\n        else {\r\n            if (this.metadataState === ConnectionState.Disconnecting) {\r\n                await waitFor(() => this.metadataState === ConnectionState.Disconnected);\r\n            }\r\n\r\n            if (this.metadataState === ConnectionState.Disconnected) {\r\n                await this.hub.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    private async maybeJoin(): Promise<void> {\r\n        await this.maybeStart();\r\n\r\n        if (this.currentRoom !== this.lastRoom) {\r\n            await this.maybeLeave();\r\n\r\n            if (this.currentRoom && this.isConnected) {\r\n                this.lastRoom = this.currentRoom;\r\n                await this.hub.invoke(\"join\", this.currentRoom);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async maybeIdentify(): Promise<void> {\r\n        await this.maybeJoin();\r\n\r\n        if (this.currentUserID\r\n            && this.currentUserID !== this.lastUserID\r\n            && this.isConnected) {\r\n            this.lastUserID = this.currentUserID;\r\n            await this.hub.invoke(\"identify\", this.currentUserID);\r\n        }\r\n    }\r\n\r\n    private async maybeLeave(): Promise<void> {\r\n        if (this.isConnected) {\r\n            await this.hub.invoke(\"leave\");\r\n        }\r\n    }\r\n\r\n    private async maybeDisconnect() {\r\n        if (this.metadataState === ConnectionState.Disconnecting) {\r\n            await waitFor(() => this.metadataState === ConnectionState.Disconnected);\r\n        }\r\n        else {\r\n            if (this.metadataState === ConnectionState.Connecting) {\r\n                await waitFor(() => this.metadataState === ConnectionState.Connected);\r\n            }\r\n\r\n            if (this.metadataState === ConnectionState.Connected) {\r\n                await this.hub.stop();\r\n            }\r\n        }\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        await this.maybeStart();\r\n    }\r\n\r\n    async join(roomName: string): Promise<void> {\r\n        this.currentRoom = roomName;\r\n        await this.maybeJoin();\r\n    }\r\n\r\n    async identify(userID: string): Promise<void> {\r\n        this.currentUserID = userID;\r\n        await this.maybeJoin();\r\n        await this.maybeIdentify();\r\n    }\r\n\r\n    async leave(): Promise<void> {\r\n        await this.maybeLeave();\r\n        this.currentUserID\r\n            = this.lastUserID\r\n            = this.currentRoom\r\n            = this.lastRoom\r\n            = null;\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        await this.maybeDisconnect();\r\n        this.currentUserID\r\n            = this.lastUserID\r\n            = this.currentRoom\r\n            = this.lastRoom\r\n            = null;\r\n    }\r\n\r\n    protected async callInternal(command: CallaEventType, toUserID: string, ...args: any[]): Promise<void> {\r\n        await this.maybeIdentify();\r\n        if (this.isConnected) {\r\n            await this.hub.invoke(command, toUserID, ...args);\r\n        }\r\n    }\r\n}\r\n"],"names":["isFunction","obj","o","c","Function","canChangeAudioOutput","HTMLAudioElement","prototype","setSinkId","LogLevel","errorMessage","statusCode","trueProto","_this","_super","__proto__","__extends","Error","statusText","content","this","HttpClient","url","options","send","method","NullLogger","_logLevel","_message","Arg","val","name","match","values","Object","Platform","window","self","isBrowser","isWebWorker","data","includeContent","detail","isArrayBuffer","byteLength","view","Uint8Array","str","forEach","num","toString","substr","length","formatArrayBuffer","ArrayBuffer","constructor","logger","transportName","httpClient","accessTokenFactory","logMessageContent","withCredentials","defaultHeaders","headers","token","_c","_b","getUserAgentHeader","value","log","Trace","getDataDetail","responseType","post","response","subject","observer","SubjectSubscription","index","observers","indexOf","splice","cancelCallback","catch","_","minimumLogLevel","outputConsole","console","ConsoleLogger","logLevel","message","Critical","error","Date","toISOString","Warning","warn","Information","info","userAgentHeaderName","isNode","constructUserAgent","getOsName","getRuntime","getRuntimeVersion","version","os","runtime","runtimeVersion","userAgent","majorAndMinor","split","process","platform","versions","node","fetch","requireFunc","__webpack_require__","__non_webpack_require__","require","jar","CookieJar","fetchType","abortControllerType","bind","AbortController","FetchHttpClient","request","abortSignal","aborted","AbortError","abortController","onabort","abort","timeoutId","timeout","msTimeout","setTimeout","TimeoutError","body","cache","credentials","Content-Type","X-Requested-With","mode","redirect","signal","_a","e_1","clearTimeout","ok","HttpError","status","arrayBuffer","text","deserializeContent","payload","HttpResponse","cookies","getCookies","e","join","MessageType","XhrHttpClient","Promise","reject","resolve","xhr","XMLHttpRequest","open","undefined","setRequestHeader","keys","header","onload","responseText","onerror","ontimeout","DefaultHttpClient","getCookieString","TextMessageFormat","output","RecordSeparator","input","messages","pop","String","fromCharCode","RecordSeparatorCode","HandshakeProtocol","handshakeRequest","write","JSON","stringify","messageData","remainingData","Buffer","binaryData","separatorIndex","responseLength","apply","slice","buffer","textData","substring","parse","type","HubConnectionState","Subject","item","_i","next","err","complete","push","HttpTransportType","TransferFormat","connection","protocol","reconnectPolicy","isRequired","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","handshakeProtocol","onreceive","processIncomingData","onclose","connectionClosed","callbacks","methods","closedCallbacks","reconnectingCallbacks","reconnectedCallbacks","invocationId","receivedHandshakeResponse","connectionState","Disconnected","connectionStarted","cachedPingMessage","writeMessage","Ping","HubConnection","connectionId","baseUrl","Reconnecting","startPromise","startWithStateTransitions","Connecting","Debug","startInternal","Connected","stopDuringStartError","handshakePromise","handshakeResolver","handshakeRejecter","start","transferFormat","sendMessage","writeHandshakeRequest","cleanupTimeout","resetTimeoutPeriod","resetKeepAliveInterval","e_2","cleanupPingTimer","stop","stopPromise","stopInternal","Disconnecting","reconnectDelayHandle","completeClose","methodName","args","promiseQueue","streams","streamIds","invocationDescriptor","createStreamInvocation","cancelInvocation","createCancelInvocation","then","sendWithProtocol","invocationEvent","Completion","launchStreams","sendPromise","createInvocation","p","result","newMethod","toLowerCase","handlers","removeIdx","callback","processHandshakeResponse","messages_1","parseMessages","Invocation","invokeClientMethod","StreamItem","Close","allowReconnect","responseMessage","features","inherentKeepAlive","pingServerHandle","timeoutHandle","serverTimeout","invocationMessage","target","m","arguments","cancelCallbacksWithError","reconnect","reconnectStartTime","now","previousReconnectAttempts","retryError","nextRetryDelay","getNextRetryDelay","onreconnecting","onreconnected","e_4","previousRetryCount","elapsedMilliseconds","retryReason","nextRetryDelayInMilliseconds","key","nonblocking","streamId","subscribe","createCompletionMessage","createStreamItemMessage","i","argument","isObservable","arg","StreamInvocation","id","CancelInvocation","DEFAULT_RETRY_DELAYS_IN_MILLISECONDS","retryDelays","DefaultReconnectPolicy","retryContext","isAborted","pollAbort","running","LongPollingTransport","isIn","Binary","pollOptions","getAccessToken","updateHeaderToken","pollUrl","get","closeError","receiving","poll","pollAborted","raiseOnClose","name_1","deleteOptions","delete","logMessage","eventSourceConstructor","ServerSentEventsTransport","encodeURIComponent","opened","Text","eventSource","Cookie","onmessage","close","onopen","webSocketConstructor","WebSocketTransport","webSocket","replace","binaryType","_event","event","ErrorEvent","readyState","OPEN","isCloseEvent","wasClean","code","reason","instance","resolveUrl","webSocketModule","eventSourceModule","WebSocket","EventSource","HttpConnection","startInternalPromise","sendQueue","TransportSendQueue","transport","stopPromiseResolver","stopError","stopConnection","skipNegotiation","WebSockets","constructTransport","startTransport","negotiateResponse","redirects","this_1","getNegotiationResponse","ProtocolVersion","accessToken","accessToken_1","createTransport","e_3","negotiateUrl","resolveNegotiateUrl","negotiateVersion","connectionToken","requestedTransport","requestedTransferFormat","connectUrl","createConnectUrl","isITransport","transportExceptions","transports","availableTransports","negotiate","transports_1","endpoint","transportOrError","resolveTransportOrError","ex_1","ex_2","ServerSentEvents","LongPolling","connect","actualTransport","transportMatches","transferFormats","map","s","ex","lastIndexOf","document","aTag","createElement","href","sendBufferedData","PromiseSource","transportResult","sendLoopPromise","sendLoop","bufferData","promise","executing","concatBuffers","error_1","arrayBuffers","totalLength","b","reduce","a","offset","arrayBuffers_1","set","resolver","rejecter","JsonHubProtocol","hubMessages","parsedMessage","isInvocationMessage","isStreamItemMessage","isCompletionMessage","assertNotEmptyString","LogLevelNameMapping","trace","debug","information","warning","critical","none","None","StreamType","StreamOpType","ConnectionState","HubConnectionBuilder","logging","mapping","parseLogLevel","transportTypeOrOptions","isNotEmpty","httpConnectionOptions","retryDelaysOrReconnectPolicy","Array","isArray","create","waitFor","test","handle","setInterval","clearInterval","Emoji","[object Object]","desc","props","contains","CallaEvent","Event","eventType","super","CallaUserEvent","CallaPoseEvent","px","py","pz","fx","fy","fz","ux","uy","uz","CallaUserPosedEvent","CallaUserPointerEvent","CallaEmojiEvent","emoji","CallaEmoteEvent","CallaEmojiAvatarEvent","CallaAvatarChangedEvent","CallaChatEvent","TypedEventBase","Map","listeners","find","listenerOptions","removeListener","idx","findIndex","arr","arrayRemoveAt","has","evt","once","call","defaultPrevented","mappedCallback","mappedCallbacks","addEventListener","removeEventListener","BaseMetadataClient","sleepTime","evtName","userID","getter","isConnected","metadataState","command","tasks","performance","task","callInternal","delta","dt","callThrottled","callImmediate","arrayScan","tests","PREFERRED_AUDIO_OUTPUT_ID_KEY","PREFERRED_AUDIO_INPUT_ID_KEY","PREFERRED_VIDEO_INPUT_ID_KEY","DEFAULT_LOCAL_USER_ID","loggingEnabled","location","hostname","search","AudioActivityEvent","seal","isActive","ClientState","audioActivityEvt","fetcher","audio","needsAudioDevice","needsVideoDevice","setConnectionState","setConferenceState","_connectionState","state","conferenceState","_conferenceState","localUserID","dispatchEvent","preferredAudioInputID","localStorage","getItem","v","setItem","preferredVideoInputID","setPreferredAudioInput","setPreferredVideoInput","setPreferredAudioOutput","allowAny","getAudioInputDevices","d","deviceId","device","getPreferredAudioInput","setAudioInputDevice","getVideoInputDevices","label","getPreferredVideoInput","setVideoInputDevice","devices","navigator","mediaDevices","enumerateDevices","hasAudioPermission","kind","hasVideoPermission","getUserMedia","video","exp","getDevices","filterDuplicates","filtered","found","j","filterDeviceDuplicates","audioOutput","filter","audioInput","videoInput","getAvailableDevices","preferredAudioOutputID","curId","getAudioOutputDeviceID","getAudioOutputDevices","getPreferredAudioOutput","setAudioOutputDevice","_roomName","_password","_fetcher","_tele","_meta","fwd","async","user","createLocalUser","pose","setPreferredDevices","joinEvt","source","createUser","removeUser","getUser","stream","setUserStream","offsetEvt","poseEvt","O","getUserOffset","setUserPose","dispose","tele","meta","getCurrentAudioOutputDevice","getMediaPermissions","leave","disconnect","offsetRadius","setLocalPose","setLocalPoseImmediate","setLocalPointer","setAvatarEmoji","setAvatarURL","emote","chat","getCurrentAudioInputDevice","getCurrentVideoInputDevice","toggleAudioMuted","toggleVideoMuted","getAudioMuted","getVideoMuted","localUserName","roomName","userExists","getUserNames","userName","identify","update","setAudioOutputDeviceID","muted","isMuted","isAudioMuted","isVideoMuted","signalRPath","hub","withUrl","build","lastRoom","lastUserID","on","fromUserID","x","assertNever","maybeStart","currentRoom","maybeLeave","invoke","maybeJoin","currentUserID","maybeIdentify","maybeDisconnect","toUserID","rest"],"mappings":"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"}