{"version":3,"file":"calla.min.js","sources":["../../Kudzu/typeChecks.ts","../audio/canChangeAudioOutput.ts","../signalr/TextMessageFormat.ts","../signalr/ILogger.ts","../signalr/Loggers.ts","../signalr/Utils.ts","../signalr/HandshakeProtocol.ts","../signalr/IHubProtocol.ts","../signalr/Subject.ts","../signalr/HubConnection.ts","../signalr/DefaultReconnectPolicy.ts","../signalr/Errors.ts","../signalr/HttpClient.ts","../signalr/FetchHttpClient.ts","../signalr/XhrHttpClient.ts","../signalr/DefaultHttpClient.ts","../signalr/ITransport.ts","../signalr/AbortController.ts","../signalr/LongPollingTransport.ts","../signalr/ServerSentEventsTransport.ts","../signalr/WebSocketTransport.ts","../signalr/HttpConnection.ts","../signalr/JsonHubProtocol.ts","../signalr/HubConnectionBuilder.ts","../../Kudzu/events/waitFor.ts","../../Kudzu/emoji/Emoji.ts","../CallaEvents.ts","../ConnectionState.ts","../../Kudzu/events/EventBase.ts","../../Kudzu/arrays/arrayRemoveAt.ts","../meta/BaseMetadataClient.ts","../../Kudzu/events/sleep.ts","../../Kudzu/arrays/arrayScan.ts","../tele/BaseTeleconferenceClient.ts","../audio/AudioActivityEvent.ts","../Calla.ts","../index.ts","../meta/signalr/SignalRMetadataClient.ts"],"sourcesContent":["function t(o: any, s: string, c: Function) {\r\n    return typeof o === s\r\n        || o instanceof c;\r\n}\r\n\r\nexport function isFunction(obj: any): obj is Function {\r\n    return t(obj, \"function\", Function);\r\n}\r\n\r\nexport function isString(obj: any): obj is string {\r\n    return t(obj, \"string\", String);\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n    return t(obj, \"boolean\", Boolean);\r\n}\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n    return t(obj, \"number\", Number);\r\n}\r\n\r\nexport function isObject(obj: any): obj is object {\r\n    return t(obj, \"object\", Object);\r\n}\r\n\r\nexport function isDate(obj: any): obj is Date {\r\n    return obj instanceof Date;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n    return obj instanceof Array;\r\n}\r\n\r\nexport function isHTMLElement(obj: any): obj is HTMLElement {\r\n    return obj instanceof HTMLElement;\r\n}\r\n\r\nexport function assertNever(x: never, msg?: string): never {\r\n    throw new Error((msg || \"Unexpected object: \") + x);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is not the special NaN value.\r\n */\r\nexport function isGoodNumber(obj: any): obj is number {\r\n    return isNumber(obj)\r\n        && !Number.isNaN(obj);\r\n}\r\n\r\nexport function isEventListener(obj: EventListenerOrEventListenerObject): obj is EventListener {\r\n    return isFunction(obj);\r\n}\r\n\r\nexport function isEventListenerObject(obj: EventListenerOrEventListenerObject): obj is EventListenerObject {\r\n    return !isEventListener(obj);\r\n}\r\n\r\nexport function isNullOrUndefined(obj: any): obj is null | undefined {\r\n    return obj === null\r\n        || obj === undefined;\r\n}","import { isFunction } from \"kudzu/typeChecks\";\r\n\r\n/**\r\n * Indicates whether or not the current browser can change the destination device for audio output.\r\n **/\r\nexport const canChangeAudioOutput = isFunction((HTMLAudioElement.prototype as any).setSinkId);","ï»¿// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    public static RecordSeparatorCode = 0x1e;\r\n    public static RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n\r\n    public static write(output: string): string {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n\r\n    public static parse(input: string): string[] {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport enum LogLevel {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    Trace = 0,\r\n    /** Log level for low severity diagnostic messages. */\r\n    Debug = 1,\r\n    /** Log level for informational diagnostic messages. */\r\n    Information = 2,\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    Warning = 3,\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    Error = 4,\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    Critical = 5,\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    None = 6,\r\n}\r\n\r\n/** An abstraction that provides a sink for diagnostic messages. */\r\nexport interface ILogger {\r\n    /** Called by the framework to emit a diagnostic message.\r\n     *\r\n     * @param {LogLevel} logLevel The severity level of the message.\r\n     * @param {string} message The message.\r\n     */\r\n    log(logLevel: LogLevel, message: string): void;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger implements ILogger {\r\n    /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\n    public static instance: ILogger = new NullLogger();\r\n\r\n    private constructor() {}\r\n\r\n    /** @inheritDoc */\r\n    // tslint:disable-next-line\r\n    public log(_logLevel: LogLevel, _message: string): void {\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\n\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexport const VERSION: string = \"0.0.0-DEV_BUILD\";\r\n\r\n/** @private */\r\nexport class Arg {\r\n    public static isRequired(val: any, name: string): void {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    public static isNotEmpty(val: string, name: string): void {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n\r\n    public static isIn(val: any, values: any, name: string): void {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class Platform {\r\n    public static get isBrowser(): boolean {\r\n        return typeof window === \"object\";\r\n    }\r\n\r\n    public static get isWebWorker(): boolean {\r\n        return typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getDataDetail(data: any, includeContent: boolean): string {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    } else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n\r\n/** @private */\r\nexport function formatArrayBuffer(data: ArrayBuffer): string {\r\n    const view = new Uint8Array(data);\r\n\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\n/** @private */\r\nexport async function sendMessage(logger: ILogger, transportName: string, httpClient: HttpClient, url: string, accessTokenFactory: (() => string | Promise<string>) | undefined,\r\n    content: string | ArrayBuffer, logMessageContent: boolean, withCredentials: boolean, defaultHeaders: MessageHeaders): Promise<void> {\r\n    let headers = {};\r\n    if (accessTokenFactory) {\r\n        const token = await accessTokenFactory();\r\n        if (token) {\r\n            headers = {\r\n                [\"Authorization\"]: `Bearer ${token}`,\r\n            };\r\n        }\r\n    }\r\n\r\n    const [name, value] = getUserAgentHeader();\r\n    (headers as any)[name] = value;\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, logMessageContent)}.`);\r\n\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...defaultHeaders },\r\n        responseType,\r\n        withCredentials,\r\n    });\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n\r\n/** @private */\r\nexport function createLogger(logger?: ILogger | LogLevel) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n\r\n    if ((logger as ILogger).log) {\r\n        return logger as ILogger;\r\n    }\r\n\r\n    return new ConsoleLogger(logger as LogLevel);\r\n}\r\n\r\n/** @private */\r\nexport class SubjectSubscription<T> implements ISubscription<T> {\r\n    private subject: Subject<T>;\r\n    private observer: IStreamSubscriber<T>;\r\n\r\n    constructor(subject: Subject<T>, observer: IStreamSubscriber<T>) {\r\n        this.subject = subject;\r\n        this.observer = observer;\r\n    }\r\n\r\n    public dispose(): void {\r\n        const index: number = this.subject.observers.indexOf(this.observer);\r\n        if (index > -1) {\r\n            this.subject.observers.splice(index, 1);\r\n        }\r\n\r\n        if (this.subject.observers.length === 0 && this.subject.cancelCallback) {\r\n            this.subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class ConsoleLogger implements ILogger {\r\n    private readonly minimumLogLevel: LogLevel;\r\n\r\n    // Public for testing purposes.\r\n    public outputConsole: {\r\n        error(message: any): void,\r\n        warn(message: any): void,\r\n        info(message: any): void,\r\n        log(message: any): void,\r\n    };\r\n\r\n    constructor(minimumLogLevel: LogLevel) {\r\n        this.minimumLogLevel = minimumLogLevel;\r\n        this.outputConsole = console;\r\n    }\r\n\r\n    public log(logLevel: LogLevel, message: string): void {\r\n        if (logLevel >= this.minimumLogLevel) {\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.outputConsole.error(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.outputConsole.warn(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.outputConsole.info(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.outputConsole.log(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getUserAgentHeader(): [string, string] {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\r\n}\r\n\r\n/** @private */\r\nexport function constructUserAgent(version: string, os: string, runtime: string, runtimeVersion: string | undefined): string {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent: string = \"Microsoft SignalR/\";\r\n\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    } else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n\r\n    userAgent += `${runtime}`;\r\n\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    } else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n\r\nfunction getOsName(): string {\r\n    return navigator.platform;\r\n}\r\n\r\nfunction getRuntimeVersion(): string | undefined {\r\n    return undefined;\r\n}\r\n\r\nfunction getRuntime(): string {\r\n    return \"Browser\";\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n/** @private */\r\nexport interface HandshakeRequestMessage {\r\n    readonly protocol: string;\r\n    readonly version: number;\r\n}\r\n\r\n/** @private */\r\nexport interface HandshakeResponseMessage {\r\n    readonly error: string;\r\n    readonly minorVersion: number;\r\n}\r\n\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    public writeHandshakeRequest(handshakeRequest: HandshakeRequestMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n\r\n    public parseHandshakeResponse(data: any): [any, HandshakeResponseMessage] {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let messageData: string;\r\n        let remainingData: any;\r\n\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, (binaryData.slice(0, responseLength) as unknown) as number[]);\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        } else {\r\n            const textData: string = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        responseMessage = response;\r\n\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { ILogger } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\n\r\n/** Defines the type of a Hub Message. */\r\nexport enum MessageType {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    Invocation = 1,\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    StreamItem = 2,\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    Completion = 3,\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    StreamInvocation = 4,\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    CancelInvocation = 5,\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    Ping = 6,\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    Close = 7,\r\n}\r\n\r\n/** Defines a dictionary of string keys and string values representing headers attached to a Hub message. */\r\nexport interface MessageHeaders {\r\n    /** Gets or sets the header with the specified key. */\r\n    [key: string]: string;\r\n}\r\n\r\n/** Union type of all known Hub messages. */\r\nexport type HubMessage =\r\n    InvocationMessage |\r\n    StreamInvocationMessage |\r\n    StreamItemMessage |\r\n    CompletionMessage |\r\n    CancelInvocationMessage |\r\n    PingMessage |\r\n    CloseMessage;\r\n\r\n/** Defines properties common to all Hub messages. */\r\nexport interface HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageType} value indicating the type of this message. */\r\n    readonly type: MessageType;\r\n}\r\n\r\n/** Defines properties common to all Hub messages relating to a specific invocation. */\r\nexport interface HubInvocationMessage extends HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageHeaders} dictionary containing headers attached to the message. */\r\n    readonly headers?: MessageHeaders;\r\n    /** The ID of the invocation relating to this message.\r\n     *\r\n     * This is expected to be present for {@link @microsoft/signalr.StreamInvocationMessage} and {@link @microsoft/signalr.CompletionMessage}. It may\r\n     * be 'undefined' for an {@link @microsoft/signalr.InvocationMessage} if the sender does not expect a response.\r\n     */\r\n    readonly invocationId?: string;\r\n}\r\n\r\n/** A hub message representing a non-streaming invocation. */\r\nexport interface InvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Invocation;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a streaming invocation. */\r\nexport interface StreamInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamInvocation;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a single item produced as part of a result stream. */\r\nexport interface StreamItemMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamItem;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n\r\n    /** The item produced by the server. */\r\n    readonly item?: any;\r\n}\r\n\r\n/** A hub message representing the result of an invocation. */\r\nexport interface CompletionMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Completion;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The error produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly error?: string;\r\n    /** The result produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly result?: any;\r\n}\r\n\r\n/** A hub message indicating that the sender is still active. */\r\nexport interface PingMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Ping;\r\n}\r\n\r\n/** A hub message indicating that the sender is closing the connection.\r\n *\r\n * If {@link @microsoft/signalr.CloseMessage.error} is defined, the sender is closing the connection due to an error.\r\n */\r\nexport interface CloseMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Close;\r\n    /** The error that triggered the close, if any.\r\n     *\r\n     * If this property is undefined, the connection was closed normally and without error.\r\n     */\r\n    readonly error?: string;\r\n\r\n    /** If true, clients with automatic reconnects enabled should attempt to reconnect after receiving the CloseMessage. Otherwise, they should not. */\r\n    readonly allowReconnect?: boolean;\r\n}\r\n\r\n/** A hub message sent to request that a streaming invocation be canceled. */\r\nexport interface CancelInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.CancelInvocation;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n}\r\n\r\n/** A protocol abstraction for communicating with SignalR Hubs.  */\r\nexport interface IHubProtocol {\r\n    /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n    readonly name: string;\r\n    /** The version of the protocol. */\r\n    readonly version: number;\r\n    /** The {@link @microsoft/signalr.TransferFormat} of the protocol. */\r\n    readonly transferFormat: TransferFormat;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the `input` parameter must be a string, otherwise it must be an ArrayBuffer.\r\n     *\r\n     * @param {string | ArrayBuffer} input A string, ArrayBuffer, or Buffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input: string | ArrayBuffer, logger: ILogger): HubMessage[];\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string or ArrayBuffer and returns it.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the result of this method will be a string, otherwise it will be an ArrayBuffer.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string | ArrayBuffer} A string or ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message: HubMessage): string | ArrayBuffer;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { IStreamResult, IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { SubjectSubscription } from \"./Utils\";\r\n\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject<T> implements IStreamResult<T> {\r\n    /** @internal */\r\n    public observers: Array<IStreamSubscriber<T>>;\r\n\r\n    /** @internal */\r\n    public cancelCallback?: () => Promise<void>;\r\n\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n\r\n    public next(item: T): void {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n\r\n    public error(err: any): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    public complete(): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n\r\n    public subscribe(observer: IStreamSubscriber<T>): ISubscription<T> {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg } from \"./Utils\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\r\n\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport enum HubConnectionState {\r\n    /** The hub connection is disconnected. */\r\n    Disconnected = \"Disconnected\",\r\n    /** The hub connection is connecting. */\r\n    Connecting = \"Connecting\",\r\n    /** The hub connection is connected. */\r\n    Connected = \"Connected\",\r\n    /** The hub connection is disconnecting. */\r\n    Disconnecting = \"Disconnecting\",\r\n    /** The hub connection is reconnecting. */\r\n    Reconnecting = \"Reconnecting\",\r\n}\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly cachedPingMessage: string | ArrayBuffer;\r\n    private readonly connection: IConnection;\r\n    private readonly logger: ILogger;\r\n    private readonly reconnectPolicy?: IRetryPolicy;\r\n    private protocol: IHubProtocol;\r\n    private handshakeProtocol: HandshakeProtocol;\r\n    private callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\r\n    private methods: { [name: string]: Array<(...args: any[]) => void> };\r\n    private invocationId: number;\r\n\r\n    private closedCallbacks: Array<(error?: Error) => void>;\r\n    private reconnectingCallbacks: Array<(error?: Error) => void>;\r\n    private reconnectedCallbacks: Array<(connectionId?: string) => void>;\r\n\r\n    private receivedHandshakeResponse: boolean;\r\n    private handshakeResolver!: (value?: PromiseLike<{}>) => void;\r\n    private handshakeRejecter!: (reason?: any) => void;\r\n    private stopDuringStartError?: Error;\r\n\r\n    private connectionState: HubConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private connectionStarted: boolean;\r\n    private startPromise?: Promise<void>;\r\n    private stopPromise?: Promise<void>;\r\n\r\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\r\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\r\n    // we built the bundle from the compiled JavaScript).\r\n    private reconnectDelayHandle?: any;\r\n    private timeoutHandle?: any;\r\n    private pingServerHandle?: any;\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** Default interval at which to ping the server.\r\n     *\r\n     * The default value is 15,000 milliseconds (15 seconds).\r\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\r\n     */\r\n    public keepAliveIntervalInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy): HubConnection {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    }\r\n\r\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.reconnectPolicy = reconnectPolicy;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this.processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this.connectionClosed(error);\r\n\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.reconnectingCallbacks = [];\r\n        this.reconnectedCallbacks = [];\r\n        this.invocationId = 0;\r\n        this.receivedHandshakeResponse = false;\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n\r\n        this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state(): HubConnectionState {\r\n        return this.connectionState;\r\n    }\r\n\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId(): string | null {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl(): string {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url: string) {\r\n        if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n\r\n        this.connection.baseUrl = url;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public start(): Promise<void> {\r\n        this.startPromise = this.startWithStateTransitions();\r\n        return this.startPromise;\r\n    }\r\n\r\n    private async startWithStateTransitions(): Promise<void> {\r\n        if (this.connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Connecting;\r\n        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        try {\r\n            await this.startInternal();\r\n\r\n            this.connectionState = HubConnectionState.Connected;\r\n            this.connectionStarted = true;\r\n            this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        } catch (e) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async startInternal() {\r\n        this.stopDuringStartError = undefined;\r\n        this.receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this.handshakeResolver = resolve;\r\n            this.handshakeRejecter = reject;\r\n        });\r\n\r\n        await this.connection.start(this.protocol.transferFormat);\r\n\r\n        try {\r\n            const handshakeRequest: HandshakeRequestMessage = {\r\n                protocol: this.protocol.name,\r\n                version: this.protocol.version,\r\n            };\r\n\r\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n            await this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n            this.logger.log(LogLevel.Information, `Using HubProtocol '${this.protocol.name}'.`);\r\n\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this.cleanupTimeout();\r\n            this.resetTimeoutPeriod();\r\n            this.resetKeepAliveInterval();\r\n\r\n            await handshakePromise;\r\n\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this.stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                throw this.stopDuringStartError;\r\n            }\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n\r\n            this.cleanupTimeout();\r\n            this.cleanupPingTimer();\r\n\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public async stop(): Promise<void> {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this.startPromise;\r\n\r\n        this.stopPromise = this.stopInternal();\r\n        await this.stopPromise;\r\n\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n\r\n    private stopInternal(error?: Error): Promise<void> {\r\n        if (this.connectionState === HubConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this.stopPromise!;\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Disconnecting;\r\n\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        if (this.reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n\r\n            clearTimeout(this.reconnectDelayHandle);\r\n            this.reconnectDelayHandle = undefined;\r\n\r\n            this.completeClose();\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\r\n\r\n        let promiseQueue: Promise<void>;\r\n        const subject = new Subject<T>();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation: CancelInvocationMessage = this.createCancelInvocation(invocationDescriptor.invocationId);\r\n\r\n            delete this.callbacks[invocationDescriptor.invocationId];\r\n\r\n            return promiseQueue.then(() => {\r\n                return this.sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n\r\n        this.callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            } else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    } else {\r\n                        subject.complete();\r\n                    }\r\n                } else {\r\n                    subject.next((invocationEvent.item) as T);\r\n                }\r\n            }\r\n        };\r\n\r\n        promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        this.launchStreams(streams, promiseQueue);\r\n\r\n        return subject;\r\n    }\r\n\r\n    private sendMessage(message: any) {\r\n        this.resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    private sendWithProtocol(message: any) {\r\n        return this.sendMessage(this.protocol.writeMessage(message));\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\r\n\r\n        this.launchStreams(streams, sendPromise);\r\n\r\n        return sendPromise;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this.callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                } else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        } else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    } else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    // invocationId will always have a value for a non-blocking invocation\r\n                    delete this.callbacks[invocationDescriptor.invocationId!];\r\n                });\r\n\r\n            this.launchStreams(streams, promiseQueue);\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => void) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this.methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    public onreconnecting(callback: (error?: Error) => void) {\r\n        if (callback) {\r\n            this.reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    public onreconnected(callback: (connectionId?: string) => void) {\r\n        if (callback) {\r\n            this.reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private processIncomingData(data: any) {\r\n        this.cleanupTimeout();\r\n\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this.protocol.parseMessages(data, this.logger);\r\n\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        const callback = this.callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n\r\n                            // tslint:disable-next-line:no-floating-promises\r\n                            this.connection.stop(error);\r\n                        } else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this.stopPromise = this.stopInternal(error);\r\n                        }\r\n\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.resetTimeoutPeriod();\r\n    }\r\n\r\n    private processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this.handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        this.handshakeResolver();\r\n        return remainingData;\r\n    }\r\n\r\n    private resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n\r\n        this.cleanupPingTimer();\r\n        this.pingServerHandle = setTimeout(async () => {\r\n            if (this.connectionState === HubConnectionState.Connected) {\r\n                try {\r\n                    await this.sendMessage(this.cachedPingMessage);\r\n                } catch {\r\n                    // We don't care about the error. It should be seen elsewhere in the client.\r\n                    // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                    this.cleanupPingTimer();\r\n                }\r\n            }\r\n        }, this.keepAliveIntervalInMilliseconds);\r\n    }\r\n\r\n    private resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n        }\r\n    }\r\n\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach((m) => m.apply(this, invocationMessage.arguments));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `A callback for the method ${invocationMessage.target.toLowerCase()} threw error '${e}'.`);\r\n            }\r\n\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n\r\n                // We don't want to wait on the stop itself.\r\n                this.stopPromise = this.stopInternal(new Error(message));\r\n            }\r\n        } else {\r\n            this.logger.log(LogLevel.Warning, `No client method with the name '${invocationMessage.target}' found.`);\r\n        }\r\n    }\r\n\r\n    private connectionClosed(error?: Error) {\r\n        this.logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this.connectionState}.`);\r\n\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this.handshakeResolver) {\r\n            this.handshakeResolver();\r\n        }\r\n\r\n        this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.completeClose(error);\r\n        } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.reconnect(error);\r\n        } else if (this.connectionState === HubConnectionState.Connected) {\r\n            this.completeClose(error);\r\n        }\r\n\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n\r\n    private completeClose(error?: Error) {\r\n        if (this.connectionStarted) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.connectionStarted = false;\r\n\r\n            try {\r\n                this.closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async reconnect(error?: Error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n\r\n        let nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n\r\n        if (nextRetryDelay === null) {\r\n            this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this.completeClose(error);\r\n            return;\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Reconnecting;\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n\r\n        if (this.onreconnecting) {\r\n            try {\r\n                this.reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        while (nextRetryDelay !== null) {\r\n            this.logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n\r\n            await new Promise((resolve) => {\r\n                this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\r\n            });\r\n            this.reconnectDelayHandle = undefined;\r\n\r\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this.startInternal();\r\n\r\n                this.connectionState = HubConnectionState.Connected;\r\n                this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n\r\n                if (this.onreconnected) {\r\n                    try {\r\n                        this.reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    } catch (e) {\r\n                        this.logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n\r\n                if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                    this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect attempt. Done reconnecting.\");\r\n                    return;\r\n                }\r\n\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n\r\n        this.logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n\r\n        this.completeClose();\r\n    }\r\n\r\n    private getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\r\n        try {\r\n            return this.reconnectPolicy!.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private cancelCallbacksWithError(error: Error) {\r\n        const callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                callback(null, error);\r\n            });\r\n    }\r\n\r\n    private cleanupPingTimer(): void {\r\n        if (this.pingServerHandle) {\r\n            clearTimeout(this.pingServerHandle);\r\n        }\r\n    }\r\n\r\n    private cleanupTimeout(): void {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        } else {\r\n            const invocationId = this.invocationId;\r\n            this.invocationId++;\r\n\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private launchStreams(streams: Array<IStreamResult<any>>, promiseQueue: Promise<void>): void {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // tslint:disable-next-line:forin\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message: string;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    } else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    } else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    private replaceStreamingParams(args: any[]): [Array<IStreamResult<any>>, string[]] {\r\n        const streams: Array<IStreamResult<any>> = [];\r\n        const streamIds: string[] = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this.isObservable(argument)) {\r\n                const streamId = this.invocationId;\r\n                this.invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        return [streams, streamIds];\r\n    }\r\n\r\n    private isObservable(arg: any): arg is IStreamResult<any> {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n\r\n    private createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\r\n        const invocationId = this.invocationId;\r\n        this.invocationId++;\r\n\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        } else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n\r\n    private createStreamItemMessage(id: string, item: any): StreamItemMessage {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n\r\n    private createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { IRetryPolicy, RetryContext } from \"./IRetryPolicy\";\r\n\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n\r\n/** @private */\r\nexport class DefaultReconnectPolicy implements IRetryPolicy {\r\n    private readonly retryDelays: Array<number | null>;\r\n\r\n    constructor(retryDelays?: number[]) {\r\n        this.retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n\r\n    public nextRetryDelayInMilliseconds(retryContext: RetryContext): number | null {\r\n        return this.retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n","ï»¿// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // tslint:disable-next-line:variable-name\r\n    private __proto__: Error;\r\n\r\n    /** The HTTP status code represented by this error. */\r\n    public statusCode: number;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage: string, statusCode: number) {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        this.statusCode = statusCode;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // tslint:disable-next-line:variable-name\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // tslint:disable-next-line:variable-name\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortSignal } from \"./AbortController\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\n\r\n/** Represents an HTTP request. */\r\nexport interface HttpRequest {\r\n    /** The HTTP method to use for the request. */\r\n    method?: string;\r\n\r\n    /** The URL for the request. */\r\n    url?: string;\r\n\r\n    /** The body content for the request. May be a string or an ArrayBuffer (for binary data). */\r\n    content?: string | ArrayBuffer;\r\n\r\n    /** An object describing headers to apply to the request. */\r\n    headers?: MessageHeaders;\r\n\r\n    /** The XMLHttpRequestResponseType to apply to the request. */\r\n    responseType?: XMLHttpRequestResponseType;\r\n\r\n    /** An AbortSignal that can be monitored for cancellation. */\r\n    abortSignal?: AbortSignal;\r\n\r\n    /** The time to wait for the request to complete before throwing a TimeoutError. Measured in milliseconds. */\r\n    timeout?: number;\r\n\r\n    /** This controls whether credentials such as cookies are sent in cross-site requests. */\r\n    withCredentials?: boolean;\r\n}\r\n\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     */\r\n    constructor(statusCode: number);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code and message.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and string content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: ArrayBuffer);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string | ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string | ArrayBuffer);\r\n    constructor(\r\n        public readonly statusCode: number,\r\n        public readonly statusText?: string,\r\n        public readonly content?: string | ArrayBuffer) {\r\n    }\r\n}\r\n\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport abstract class HttpClient {\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public get(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public post(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public delete(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP request to the specified URL, returning a {@link Promise} that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {HttpRequest} request An {@link @microsoft/signalr.HttpRequest} describing the request to send.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an HttpResponse describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public abstract send(request: HttpRequest): Promise<HttpResponse>;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport * as tough from \"@types/tough-cookie\";\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly jar?: tough.CookieJar;\r\n\r\n    private readonly logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this.logger = logger;\r\n\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this.jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this.fetchType = requireFunc(\"node-fetch\");\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this.fetchType = requireFunc(\"fetch-cookie\")(this.fetchType, this.jar);\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this.abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this.fetchType = fetch.bind(self);\r\n            this.abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this.abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this.fetchType(request.url!, {\r\n                body: request.content!,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"manual\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this.logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            throw new HttpError(response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\nexport class XhrHttpClient extends HttpClient {\r\n    private readonly logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this.logger = logger;\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return new Promise<HttpResponse>((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n\r\n            xhr.open(request.method!, request.url!, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                        xhr.setRequestHeader(header, headers[header]);\r\n                    });\r\n            }\r\n\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                } else {\r\n                    reject(new HttpError(xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n\r\n            xhr.onerror = () => {\r\n                this.logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n\r\n            xhr.ontimeout = () => {\r\n                this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n\r\n            xhr.send(request.content || \"\");\r\n        });\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger } from \"./ILogger\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    private readonly httpClient: HttpClient;\r\n\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n\r\n        if (typeof fetch !== \"undefined\") {\r\n            this.httpClient = new FetchHttpClient(logger);\r\n        } else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this.httpClient = new XhrHttpClient(logger);\r\n        } else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return this.httpClient.send(request);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport enum HttpTransportType {\r\n    /** Specifies no transport preference. */\r\n    None = 0,\r\n    /** Specifies the WebSockets transport. */\r\n    WebSockets = 1,\r\n    /** Specifies the Server-Sent Events transport. */\r\n    ServerSentEvents = 2,\r\n    /** Specifies the Long Polling transport. */\r\n    LongPolling = 4,\r\n}\r\n\r\n/** Specifies the transfer format for a connection. */\r\nexport enum TransferFormat {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    Text = 1,\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    Binary = 2,\r\n}\r\n\r\n/** An abstraction over the behavior of transports. This is designed to support the framework and not intended for use by applications. */\r\nexport interface ITransport {\r\n    connect(url: string, transferFormat: TransferFormat): Promise<void>;\r\n    send(data: any): Promise<void>;\r\n    stop(): Promise<void>;\r\n    onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    onclose: ((error?: Error) => void) | null;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController implements AbortSignal {\r\n    private isAborted: boolean = false;\r\n    public onabort: (() => void) | null = null;\r\n\r\n    public abort() {\r\n        if (!this.isAborted) {\r\n            this.isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n\r\n    get signal(): AbortSignal {\r\n        return this;\r\n    }\r\n\r\n    get aborted(): boolean {\r\n        return this.isAborted;\r\n    }\r\n}\r\n\r\n/** Represents a signal that can be monitored to determine if a request has been aborted. */\r\nexport interface AbortSignal {\r\n    /** Indicates if the request has been aborted. */\r\n    aborted: boolean;\r\n    /** Set this to a handler that will be invoked when the request is aborted. */\r\n    onabort: (() => void) | null;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\n\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport implements ITransport {\r\n    private readonly httpClient: HttpClient;\r\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly logger: ILogger;\r\n    private readonly logMessageContent: boolean;\r\n    private readonly withCredentials: boolean;\r\n    private readonly pollAbort: AbortController;\r\n    private readonly headers: MessageHeaders;\r\n\r\n    private url?: string;\r\n    private running: boolean;\r\n    private receiving?: Promise<void>;\r\n    private closeError?: Error;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    public get pollAborted() {\r\n        return this.pollAbort.aborted;\r\n    }\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger, logMessageContent: boolean, withCredentials: boolean, headers: MessageHeaders) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logger = logger;\r\n        this.pollAbort = new AbortController();\r\n        this.logMessageContent = logMessageContent;\r\n        this.withCredentials = withCredentials;\r\n        this.headers = headers;\r\n\r\n        this.running = false;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.url = url;\r\n\r\n        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this.headers };\r\n\r\n        const pollOptions: HttpRequest = {\r\n            abortSignal: this.pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this.withCredentials,\r\n        };\r\n\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n\r\n        const token = await this.getAccessToken();\r\n        this.updateHeaderToken(pollOptions, token);\r\n\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this.logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this.httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this.logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this.running = false;\r\n        } else {\r\n            this.running = true;\r\n        }\r\n\r\n        this.receiving = this.poll(this.url, pollOptions);\r\n    }\r\n\r\n    private async getAccessToken(): Promise<string | null> {\r\n        if (this.accessTokenFactory) {\r\n            return await this.accessTokenFactory();\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private updateHeaderToken(request: HttpRequest, token: string | null) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (token) {\r\n            // tslint:disable-next-line:no-string-literal\r\n            request.headers[\"Authorization\"] = `Bearer ${token}`;\r\n            return;\r\n        }\r\n        // tslint:disable-next-line:no-string-literal\r\n        if (request.headers[\"Authorization\"]) {\r\n            // tslint:disable-next-line:no-string-literal\r\n            delete request.headers[\"Authorization\"];\r\n        }\r\n    }\r\n\r\n    private async poll(url: string, pollOptions: HttpRequest): Promise<void> {\r\n        try {\r\n            while (this.running) {\r\n                // We have to get the access token on each poll, in case it changes\r\n                const token = await this.getAccessToken();\r\n                this.updateHeaderToken(pollOptions, token);\r\n\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this.logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this.httpClient.get(pollUrl, pollOptions);\r\n\r\n                    if (response.statusCode === 204) {\r\n                        this.logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n\r\n                        this.running = false;\r\n                    } else if (response.statusCode !== 200) {\r\n                        this.logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n                        // Unexpected status code\r\n                        this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this.running = false;\r\n                    } else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this.logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this.logMessageContent)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        } else {\r\n                            // This is another way timeout manifest.\r\n                            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    if (!this.running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this.logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    } else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        } else {\r\n                            // Close the connection with the error as the result.\r\n                            this.closeError = e;\r\n                            this.running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this.raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this.running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this.logger, \"LongPolling\", this.httpClient, this.url!, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers);\r\n    }\r\n\r\n    public async stop(): Promise<void> {\r\n        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this.running = false;\r\n        this.pollAbort.abort();\r\n\r\n        try {\r\n            await this.receiving;\r\n\r\n            // Send DELETE to clean up long polling on the server\r\n            this.logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this.url}.`);\r\n\r\n            const headers = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            (headers as any)[name] = value;\r\n\r\n            const deleteOptions: HttpRequest = {\r\n                headers: { ...headers, ...this.headers },\r\n                withCredentials: this.withCredentials,\r\n            };\r\n            const token = await this.getAccessToken();\r\n            this.updateHeaderToken(deleteOptions, token);\r\n            await this.httpClient.delete(this.url!, deleteOptions);\r\n\r\n            this.logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\r\n        } finally {\r\n            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this.raiseOnClose();\r\n        }\r\n    }\r\n\r\n    private raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this.closeError) {\r\n                logMessage += \" Error: \" + this.closeError;\r\n            }\r\n            this.logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this.closeError);\r\n        }\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { EventSourceConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly httpClient: HttpClient;\r\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly logger: ILogger;\r\n    private readonly logMessageContent: boolean;\r\n    private readonly withCredentials: boolean;\r\n    private readonly eventSourceConstructor: EventSourceConstructor;\r\n    private eventSource?: EventSource;\r\n    private url?: string;\r\n    private headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, eventSourceConstructor: EventSourceConstructor, withCredentials: boolean, headers: MessageHeaders) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logger = logger;\r\n        this.logMessageContent = logMessageContent;\r\n        this.withCredentials = withCredentials;\r\n        this.eventSourceConstructor = eventSourceConstructor;\r\n        this.headers = headers;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\r\n        this.url = url;\r\n\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this.eventSourceConstructor(url, { withCredentials: this.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const headers: MessageHeaders = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this.eventSourceConstructor(url, { withCredentials: this.withCredentials, headers: { ...headers, ...this.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this.logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this.close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                eventSource.onerror = (e: Event) => {\r\n                    const error = new Error((e as any).data || \"Error occurred\");\r\n                    if (opened) {\r\n                        this.close(error);\r\n                    } else {\r\n                        reject(error);\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this.logger.log(LogLevel.Information, `SSE connected to ${this.url}`);\r\n                    this.eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this.eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this.logger, \"SSE\", this.httpClient, this.url!, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this.close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private close(e?: Error) {\r\n        if (this.eventSource) {\r\n            this.eventSource.close();\r\n            this.eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly logger: ILogger;\r\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly logMessageContent: boolean;\r\n    private readonly webSocketConstructor: WebSocketConstructor;\r\n    private webSocket?: WebSocket;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor) {\r\n        this.logger = logger;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logMessageContent = logMessageContent;\r\n        this.webSocketConstructor = webSocketConstructor;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            let opened = false;\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this.webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            // tslint:disable-next-line:variable-name\r\n            webSocket.onopen = (_event: Event) => {\r\n                this.logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this.webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = new Error(\"There was an error with the transport.\");\r\n                }\r\n\r\n                reject(error);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this.logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this.logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this.close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this.close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = new Error(\"There was an error with the transport.\");\r\n                    }\r\n\r\n                    reject(error);\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {\r\n            this.logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this.logMessageContent)}.`);\r\n            this.webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this.webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this.close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private close(event?: CloseEvent | Error): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this.webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this.webSocket.onclose = () => {};\r\n            this.webSocket.onmessage = () => {};\r\n            this.webSocket.onerror = () => {};\r\n            this.webSocket.close();\r\n            this.webSocket = undefined;\r\n        }\r\n\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this.isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: Array<keyof typeof TransferFormat>;\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private connectionStarted: boolean;\r\n    private readonly httpClient: HttpClient;\r\n    private readonly logger: ILogger;\r\n    private readonly options: IHttpConnectionOptions;\r\n    private transport?: ITransport;\r\n    private startInternalPromise?: Promise<void>;\r\n    private stopPromise?: Promise<void>;\r\n    private stopPromiseResolver!: (value?: PromiseLike<void>) => void;\r\n    private stopError?: Error;\r\n    private accessTokenFactory?: () => string | Promise<string>;\r\n    private sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this.logger = createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        } else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n\r\n        if (typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        }\r\n\r\n        if (typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        }\r\n\r\n        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\r\n        this.connectionState = ConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n        this.options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this.connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Connecting;\r\n\r\n        this.startInternalPromise = this.startInternal(transferFormat);\r\n        await this.startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this.connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this.stopPromise;\r\n\r\n            return Promise.reject(new Error(message));\r\n        } else if (this.connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this.logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new Error(message));\r\n        }\r\n\r\n        this.connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this.connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this.sendQueue) {\r\n            this.sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this.sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this.stopPromise;\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Disconnecting;\r\n\r\n        this.stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this.stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this.stopInternal(error);\r\n        await this.stopPromise;\r\n    }\r\n\r\n    private async stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this.stopError = error;\r\n\r\n        try {\r\n            await this.startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this.stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n            this.stopConnection();\r\n        }\r\n    }\r\n\r\n    private async startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this.accessTokenFactory = this.options.accessTokenFactory;\r\n\r\n        try {\r\n            if (this.options.skipNegotiation) {\r\n                if (this.options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this.constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this.startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this.getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this.connectionState === ConnectionState.Disconnecting || this.connectionState === ConnectionState.Disconnected) {\r\n                        throw new Error(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this.accessTokenFactory = () => accessToken;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this.connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this.connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this.connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const headers = {};\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                (headers as any)[`Authorization`] = `Bearer ${token}`;\r\n            }\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        (headers as any)[name] = value;\r\n\r\n        const negotiateUrl = this.resolveNegotiateUrl(url);\r\n        this.logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this.httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this.options.headers },\r\n                withCredentials: this.options.withCredentials,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this.isITransport(requestedTransport)) {\r\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this.startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed: ${transportOrError}`);\r\n            } else if (this.isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this.getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this.startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this.logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(`${endpoint.transport} failed: ${ex}`);\r\n\r\n                    if (this.connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this.logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new Error(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new Error(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this.options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this.options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials!, this.options.headers || {});\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials!, this.options.headers || {});\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        this.transport!.onclose = (e) => this.stopConnection(e);\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {\r\n                        this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new Error(`'${HttpTransportType[transport]}' is not supported in your environment.`);\r\n                    } else {\r\n                        this.logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this.constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new Error(`'${HttpTransportType[transport]}' is disabled by the client.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private stopConnection(error?: Error): void {\r\n        this.logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this.connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this.stopError || error;\r\n        this.stopError = undefined;\r\n\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Connecting) {\r\n            this.logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this.stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this.sendQueue) {\r\n            this.sendQueue.stop().catch((e) => {\r\n                this.logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this.sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this.connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this.connectionStarted) {\r\n            this.connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser || !window.document) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this.logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private buffer: any[] = [];\r\n    private sendBufferedData: PromiseSource;\r\n    private executing: boolean = true;\r\n    private transportResult?: PromiseSource;\r\n    private sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly transport: ITransport) {\r\n        this.sendBufferedData = new PromiseSource();\r\n        this.transportResult = new PromiseSource();\r\n\r\n        this.sendLoopPromise = this.sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this.bufferData(data);\r\n        if (!this.transportResult) {\r\n            this.transportResult = new PromiseSource();\r\n        }\r\n        return this.transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this.executing = false;\r\n        this.sendBufferedData.resolve();\r\n        return this.sendLoopPromise;\r\n    }\r\n\r\n    private bufferData(data: string | ArrayBuffer): void {\r\n        if (this.buffer.length && typeof(this.buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this.buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this.buffer.push(data);\r\n        this.sendBufferedData.resolve();\r\n    }\r\n\r\n    private async sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this.sendBufferedData.promise;\r\n\r\n            if (!this.executing) {\r\n                if (this.transportResult) {\r\n                    this.transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this.sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this.transportResult!;\r\n            this.transportResult = undefined;\r\n\r\n            const data = typeof(this.buffer[0]) === \"string\" ?\r\n                this.buffer.join(\"\") :\r\n                TransportSendQueue.concatBuffers(this.buffer);\r\n\r\n            this.buffer.length = 0;\r\n\r\n            try {\r\n                await this.transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result.buffer;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private resolver?: () => void;\r\n    private rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this.resolver, this.rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this.resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this.rejecter!(reason);\r\n    }\r\n}\r\n","ï»¿// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { CompletionMessage, HubMessage, IHubProtocol, InvocationMessage, MessageType, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\n\r\nconst JSON_HUB_PROTOCOL_NAME: string = \"json\";\r\n\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol implements IHubProtocol {\r\n\r\n    /** @inheritDoc */\r\n    public readonly name: string = JSON_HUB_PROTOCOL_NAME;\r\n    /** @inheritDoc */\r\n    public readonly version: number = 1;\r\n\r\n    /** @inheritDoc */\r\n    public readonly transferFormat: TransferFormat = TransferFormat.Text;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    public parseMessages(input: string, logger: ILogger): HubMessage[] {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n\r\n        if (!input) {\r\n            return [];\r\n        }\r\n\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message) as HubMessage;\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this.isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this.isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this.isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n\r\n        return hubMessages;\r\n    }\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    public writeMessage(message: HubMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n\r\n    private isInvocationMessage(message: InvocationMessage): void {\r\n        this.assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n\r\n        if (message.invocationId !== undefined) {\r\n            this.assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n\r\n    private isStreamItemMessage(message: StreamItemMessage): void {\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n\r\n    private isCompletionMessage(message: CompletionMessage): void {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        if (!message.result && message.error) {\r\n            this.assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n\r\n    private assertNotEmptyString(value: any, errorMessage: string): void {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { IHubProtocol } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { HttpTransportType } from \"./ITransport\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\n\r\n// tslint:disable:object-literal-sort-keys\r\nconst LogLevelNameMapping = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\n\r\nfunction parseLogLevel(name: string): LogLevel {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = (LogLevelNameMapping as any)[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    } else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    /** @internal */\r\n    public protocol?: IHubProtocol;\r\n    /** @internal */\r\n    public httpConnectionOptions?: IHttpConnectionOptions;\r\n    /** @internal */\r\n    public url?: string;\r\n    /** @internal */\r\n    public logger?: ILogger;\r\n\r\n    /** If defined, this indicates the client should automatically attempt to reconnect if the connection is lost. */\r\n    /** @internal */\r\n    public reconnectPolicy?: IRetryPolicy;\r\n\r\n    /** Configures console logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel} logLevel The minimum level of messages to log. Anything at this level, or a more severe level, will be logged.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logLevel: LogLevel): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {ILogger} logger An object implementing the {@link @microsoft/signalr.ILogger} interface, which will be used to write all log messages.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logger: ILogger): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {string} logLevel A string representing a LogLevel setting a minimum level of messages to log.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     */\r\n    public configureLogging(logLevel: string): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel | string | ILogger} logging A {@link @microsoft/signalr.LogLevel}, a string representing a LogLevel, or an object implementing the {@link @microsoft/signalr.ILogger} interface.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder;\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder {\r\n        Arg.isRequired(logging, \"logging\");\r\n\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        } else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        } else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * The transport will be selected automatically based on what the server and client support.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified HTTP-based transport to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {HttpTransportType} transportType The specific transport to use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, transportType: HttpTransportType): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {IHttpConnectionOptions} options An options object used to configure the connection.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, options: IHttpConnectionOptions): HubConnectionBuilder;\r\n    public withUrl(url: string, transportTypeOrOptions?: IHttpConnectionOptions | HttpTransportType): HubConnectionBuilder {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n\r\n        this.url = url;\r\n\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        } else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    public withHubProtocol(protocol: IHubProtocol): HubConnectionBuilder {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     * By default, the client will wait 0, 2, 10 and 30 seconds respectively before trying up to 4 reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {number[]} retryDelays An array containing the delays in milliseconds before trying each reconnect attempt.\r\n     * The length of the array represents how many failed reconnect attempts it takes before the client will stop attempting to reconnect.\r\n     */\r\n    public withAutomaticReconnect(retryDelays: number[]): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {IRetryPolicy} reconnectPolicy An {@link @microsoft/signalR.IRetryPolicy} that controls the timing and number of reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(reconnectPolicy: IRetryPolicy): HubConnectionBuilder;\r\n    public withAutomaticReconnect(retryDelaysOrReconnectPolicy?: number[] | IRetryPolicy): HubConnectionBuilder {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        } else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    public build(): HubConnection {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n\r\n        return HubConnection.create(\r\n            connection,\r\n            this.logger || NullLogger.instance,\r\n            this.protocol || new JsonHubProtocol(),\r\n            this.reconnectPolicy);\r\n    }\r\n}\r\n\r\nfunction isLogger(logger: any): logger is ILogger {\r\n    return logger.log !== undefined;\r\n}\r\n","ï»¿export function waitFor(test: () => boolean): Promise<void> {\r\n    return new Promise((resolve: () => void) => {\r\n        const handle = setInterval(() => {\r\n            if (test()) {\r\n                clearInterval(handle);\r\n                resolve();\r\n            }\r\n        }, 100);\r\n    });\r\n}\r\n","/**\r\n * Unicode-standardized pictograms.\r\n **/\r\nexport class Emoji {\r\n    props: any;\r\n\r\n    /**\r\n     * Creates a new Unicode-standardized pictograms.\r\n     * @param value - a Unicode sequence.\r\n     * @param desc - an English text description of the pictogram.\r\n     * @param props - an optional set of properties to store with the emoji.\r\n     */\r\n    constructor(public value: string, public desc: string, props: any = null) {\r\n        this.value = value;\r\n        this.desc = desc;\r\n        this.props = props || {};\r\n    }\r\n\r\n    /**\r\n     * Determines of the provided Emoji or EmojiGroup is a subset of\r\n     * this emoji.\r\n     */\r\n    contains(e: Emoji | string): boolean {\r\n        if (e instanceof Emoji) {\r\n            return this.contains(e.value);\r\n        }\r\n        else {\r\n            return this.value.indexOf(e) >= 0;\r\n        }\r\n    }\r\n}","import { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport type { AudioActivityEvent } from \"./audio/AudioActivityEvent\";\r\nimport type { InterpolatedPose } from \"./audio/positions/InterpolatedPose\";\r\nimport { AudioStreamSource } from \"./audio/sources/AudioStreamSource\";\r\n\r\nexport type CallaTeleconferenceEventType = \"serverConnected\"\r\n    | \"serverDisconnected\"\r\n    | \"serverFailed\"\r\n    | \"conferenceConnected\"\r\n    | \"conferenceJoined\"\r\n    | \"conferenceFailed\"\r\n    | \"conferenceRestored\"\r\n    | \"conferenceLeft\"\r\n    | \"participantJoined\"\r\n    | \"participantLeft\"\r\n    | \"userNameChanged\"\r\n    | \"audioMuteStatusChanged\"\r\n    | \"videoMuteStatusChanged\"\r\n    | \"audioActivity\"\r\n    | \"audioAdded\"\r\n    | \"audioRemoved\"\r\n    | \"videoAdded\"\r\n    | \"videoRemoved\";\r\n\r\nexport type CallaMetadataEventType = \"userPosed\"\r\n    | \"userPointer\"\r\n    | \"setAvatarEmoji\"\r\n    | \"avatarChanged\"\r\n    | \"emote\"\r\n    | \"chat\";\r\n\r\nexport type CallaEventType = CallaTeleconferenceEventType | CallaMetadataEventType;\r\n\r\nexport class CallaEvent<T extends CallaEventType> extends Event {\r\n    constructor(public eventType: T) {\r\n        super(eventType);\r\n    }\r\n}\r\n\r\nexport class CallaTeleconferenceServerConnectedEvent\r\n    extends CallaEvent<\"serverConnected\"> {\r\n    constructor() {\r\n        super(\"serverConnected\");\r\n    }\r\n}\r\n\r\nexport class CallaTeleconferenceServerDisconnectedEvent\r\n    extends CallaEvent<\"serverDisconnected\"> {\r\n    constructor() {\r\n        super(\"serverDisconnected\");\r\n    }\r\n}\r\n\r\nexport class CallaTeleconferenceServerFailedEvent\r\n    extends CallaEvent<\"serverFailed\"> {\r\n    constructor() {\r\n        super(\"serverFailed\");\r\n    }\r\n}\r\n\r\nexport class CallaUserEvent<T extends CallaEventType> extends CallaEvent<T> {\r\n    constructor(type: T, public id: string) {\r\n        super(type);\r\n    }\r\n}\r\n\r\nexport class CallaParticipantEvent<T extends CallaTeleconferenceEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, id: string, public displayName: string) {\r\n        super(type, id);\r\n    }\r\n}\r\n\r\nexport class CallaUserNameChangedEvent extends CallaUserEvent<\"userNameChanged\"> {\r\n    constructor(id: string, public displayName: string) {\r\n        super(\"userNameChanged\", id);\r\n    }\r\n}\r\n\r\nexport class CallaConferenceJoinedEvent extends CallaUserEvent<\"conferenceJoined\"> {\r\n    constructor(id: string, public pose: InterpolatedPose) {\r\n        super(\"conferenceJoined\", id);\r\n    }\r\n}\r\n\r\nexport class CallaConferenceLeftEvent extends CallaUserEvent<\"conferenceLeft\"> {\r\n    constructor(id: string) {\r\n        super(\"conferenceLeft\", id);\r\n    }\r\n}\r\n\r\nexport class CallaConferenceConnectedEvent extends CallaEvent<\"conferenceConnected\"> {\r\n    constructor() {\r\n        super(\"conferenceConnected\");\r\n    }\r\n}\r\n\r\nexport class CallaConferenceFailedEvent extends CallaEvent<\"conferenceFailed\">{\r\n    constructor() {\r\n        super(\"conferenceFailed\");\r\n    }\r\n}\r\n\r\nexport class CallaConferenceRestoredEvent extends CallaEvent<\"conferenceRestored\">{\r\n    constructor() {\r\n        super(\"conferenceRestored\");\r\n    }\r\n}\r\n\r\nexport class CallaParticipantJoinedEvent extends CallaParticipantEvent<\"participantJoined\"> {\r\n    constructor(id: string, displayName: string, public source: AudioStreamSource) {\r\n        super(\"participantJoined\", id, displayName);\r\n    }\r\n}\r\n\r\nexport class CallaParticipantLeftEvent extends CallaUserEvent<\"participantLeft\"> {\r\n    constructor(id: string) {\r\n        super(\"participantLeft\", id);\r\n    }\r\n}\r\n\r\nexport class CallaParticipantNameChangeEvent extends CallaParticipantEvent<\"userNameChanged\"> {\r\n    constructor(id: string, displayName: string) {\r\n        super(\"userNameChanged\", id, displayName);\r\n    }\r\n}\r\n\r\nexport class CallaUserMutedEvent<T extends CallaTeleconferenceEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, id: string, public muted: boolean) {\r\n        super(type, id);\r\n    }\r\n}\r\n\r\nexport class CallaUserAudioMutedEvent extends CallaUserMutedEvent<\"audioMuteStatusChanged\"> {\r\n    constructor(id: string, muted: boolean) {\r\n        super(\"audioMuteStatusChanged\", id, muted);\r\n    }\r\n}\r\n\r\nexport class CallaUserVideoMutedEvent extends CallaUserMutedEvent<\"videoMuteStatusChanged\"> {\r\n    constructor(id: string, muted: boolean) {\r\n        super(\"videoMuteStatusChanged\", id, muted);\r\n    }\r\n}\r\n\r\nexport enum StreamType {\r\n    Audio = \"audio\",\r\n    Video = \"video\"\r\n}\r\n\r\nexport enum StreamOpType {\r\n    Added = \"added\",\r\n    Removed = \"removed\",\r\n    Changed = \"changed\"\r\n}\r\n\r\nexport class CallaStreamEvent<T extends CallaTeleconferenceEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, public kind: StreamType, public op: StreamOpType, id: string, public stream: MediaStream) {\r\n        super(type, id);\r\n    }\r\n}\r\n\r\nexport class CallaStreamAddedEvent<T extends CallaTeleconferenceEventType> extends CallaStreamEvent<T> {\r\n    constructor(type: T, kind: StreamType, id: string, stream: MediaStream) {\r\n        super(type, kind, StreamOpType.Added, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaStreamRemovedEvent<T extends CallaTeleconferenceEventType> extends CallaStreamEvent<T> {\r\n    constructor(type: T, kind: StreamType, id: string, stream: MediaStream) {\r\n        super(type, kind, StreamOpType.Removed, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaStreamChangedEvent<T extends CallaTeleconferenceEventType> extends CallaStreamEvent<T> {\r\n    constructor(type: T, kind: StreamType, id: string, stream: MediaStream) {\r\n        super(type, kind, StreamOpType.Changed, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaAudioStreamAddedEvent extends CallaStreamAddedEvent<\"audioAdded\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"audioAdded\", StreamType.Audio, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaAudioStreamRemovedEvent extends CallaStreamRemovedEvent<\"audioRemoved\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"audioRemoved\", StreamType.Audio, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaVideoStreamAddedEvent extends CallaStreamAddedEvent<\"videoAdded\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"videoAdded\", StreamType.Video, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaVideoStreamRemovedEvent extends CallaStreamRemovedEvent<\"videoRemoved\"> {\r\n    constructor(id: string, stream: MediaStream) {\r\n        super(\"videoRemoved\", StreamType.Video, id, stream);\r\n    }\r\n}\r\n\r\nexport class CallaPoseEvent<T extends CallaMetadataEventType> extends CallaUserEvent<T> {\r\n    constructor(type: T, id: string, public px: number, public py: number, public pz: number, public fx: number, public fy: number, public fz: number, public ux: number, public uy: number, public uz: number) {\r\n        super(type, id);\r\n    }\r\n\r\n    set(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) {\r\n        this.px = px;\r\n        this.py = py;\r\n        this.pz = pz;\r\n        this.fx = fx;\r\n        this.fy = fy;\r\n        this.fz = fz;\r\n        this.ux = ux;\r\n        this.uy = uy;\r\n        this.uz = uz;\r\n    }\r\n}\r\n\r\nexport class CallaUserPosedEvent extends CallaPoseEvent<\"userPosed\"> {\r\n    constructor(id: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) {\r\n        super(\"userPosed\", id, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n}\r\n\r\nexport class CallaUserPointerEvent extends CallaPoseEvent<\"userPointer\"> {\r\n    constructor(id: string, public name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) {\r\n        super(\"userPointer\", id, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n}\r\n\r\nexport class CallaEmojiEvent<T extends CallaMetadataEventType> extends CallaUserEvent<T> {\r\n    emoji: string;\r\n    constructor(type: T, id: string, emoji: Emoji | string) {\r\n        super(type, id);\r\n        if (emoji instanceof Emoji) {\r\n            this.emoji = emoji.value;\r\n        }\r\n        else {\r\n            this.emoji = emoji;\r\n        }\r\n    }\r\n}\r\n\r\nexport class CallaEmoteEvent extends CallaEmojiEvent<\"emote\"> {\r\n    constructor(id: string, emoji: Emoji | string) {\r\n        super(\"emote\", id, emoji);\r\n    }\r\n}\r\n\r\nexport class CallaEmojiAvatarEvent extends CallaEmojiEvent<\"setAvatarEmoji\"> {\r\n    constructor(id: string, emoji: Emoji | string) {\r\n        super(\"setAvatarEmoji\", id, emoji);\r\n    }\r\n}\r\n\r\nexport class CallaAvatarChangedEvent extends CallaUserEvent<\"avatarChanged\"> {\r\n    constructor(id: string, public url: string) {\r\n        super(\"avatarChanged\", id);\r\n    }\r\n}\r\n\r\nexport class CallaChatEvent extends CallaUserEvent<\"chat\"> {\r\n    constructor(id: string, public text: string) {\r\n        super(\"chat\", id);\r\n    }\r\n}\r\n\r\nexport interface CallaTeleconferenceEvents {\r\n    serverConnected: CallaTeleconferenceServerConnectedEvent;\r\n    serverDisconnected: CallaTeleconferenceServerDisconnectedEvent;\r\n    serverFailed: CallaTeleconferenceServerFailedEvent;\r\n    audioMuteStatusChanged: CallaUserAudioMutedEvent;\r\n    videoMuteStatusChanged: CallaUserVideoMutedEvent;\r\n    conferenceConnected: CallaConferenceConnectedEvent;\r\n    conferenceJoined: CallaConferenceJoinedEvent;\r\n    conferenceLeft: CallaConferenceLeftEvent;\r\n    conferenceFailed: CallaConferenceFailedEvent;\r\n    conferenceRestored: CallaConferenceRestoredEvent;\r\n    participantJoined: CallaParticipantJoinedEvent;\r\n    participantLeft: CallaParticipantLeftEvent;\r\n    userNameChanged: CallaUserNameChangedEvent;\r\n    audioActivity: AudioActivityEvent;\r\n    audioAdded: CallaAudioStreamAddedEvent;\r\n    videoAdded: CallaVideoStreamAddedEvent;\r\n    audioRemoved: CallaAudioStreamRemovedEvent;\r\n    videoRemoved: CallaVideoStreamRemovedEvent;\r\n}\r\n\r\nexport interface CallaMetadataEvents {\r\n    userPosed: CallaUserPosedEvent;\r\n    userPointer: CallaUserPointerEvent;\r\n    emote: CallaEmoteEvent;\r\n    setAvatarEmoji: CallaEmojiAvatarEvent;\r\n    avatarChanged: CallaAvatarChangedEvent;\r\n    chat: CallaChatEvent;\r\n}\r\n\r\nexport interface CallaClientEvents extends CallaTeleconferenceEvents, CallaMetadataEvents { }","export enum ConnectionState {\r\n    Disconnected = \"Disconnected\",\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnecting = \"Disconnecting\"\r\n}","import { arrayRemoveAt } from \"../arrays/arrayRemoveAt\";\r\nimport { isFunction } from \"../typeChecks\";\r\n\r\nexport class EventBase implements EventTarget {\r\n    private listeners = new Map<string, Function[]>();\r\n    private listenerOptions = new Map<Function, AddEventListenerOptions>();\r\n\r\n    addEventListener(type: string, callback: (evt: Event) => any, options?: AddEventListenerOptions): void {\r\n        if (isFunction(callback)) {\r\n            let listeners = this.listeners.get(type);\r\n            if (!listeners) {\r\n                listeners = new Array<Function>();\r\n                this.listeners.set(type, listeners);\r\n            }\r\n\r\n            if (!listeners.find(c => c === callback)) {\r\n                listeners.push(callback);\r\n\r\n                if (options) {\r\n                    this.listenerOptions.set(callback, options);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (evt: Event) => any) {\r\n        if (isFunction(callback)) {\r\n            const listeners = this.listeners.get(type);\r\n            if (listeners) {\r\n                this.removeListener(listeners, callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeListener(listeners: Function[], callback: Function) {\r\n        const idx = listeners.findIndex(c => c === callback);\r\n        if (idx >= 0) {\r\n            arrayRemoveAt(listeners, idx);\r\n            if (this.listenerOptions.has(callback)) {\r\n                this.listenerOptions.delete(callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(evt: Event): boolean {\r\n        const listeners = this.listeners.get(evt.type);\r\n        if (listeners) {\r\n            for (const callback of listeners) {\r\n                const options = this.listenerOptions.get(callback);\r\n                if (options && options.once) {\r\n                    this.removeListener(listeners, callback);\r\n                }\r\n\r\n                callback.call(this, evt);\r\n            }\r\n        }\r\n        return !evt.defaultPrevented;\r\n    }\r\n}\r\n\r\nexport class TypedEvent<T extends string> extends Event {\r\n    constructor(type: T) {\r\n        super(type);\r\n    }\r\n}\r\n\r\nexport class TypedEventBase<EventsT> extends EventBase {\r\n    private mappedCallbacks = new Map<Function, (evt: Event) => any>();\r\n\r\n    addEventListener<K extends string & keyof EventsT>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any, options?: AddEventListenerOptions): void {\r\n        let mappedCallback = this.mappedCallbacks.get(callback);\r\n        if (mappedCallback == null) {\r\n            mappedCallback = (evt: Event) => callback(evt as TypedEvent<K> & EventsT[K]);\r\n            this.mappedCallbacks.set(callback, mappedCallback);\r\n        }\r\n\r\n        super.addEventListener(type, mappedCallback, options);\r\n    }\r\n\r\n    removeEventListener<K extends string & keyof EventsT>(type: K, callback: (evt: TypedEvent<K> & EventsT[K]) => any) {\r\n        const mappedCallback = this.mappedCallbacks.get(callback);\r\n        if (mappedCallback) {\r\n            super.removeEventListener(type, mappedCallback);\r\n        }\r\n    }\r\n}","/**\r\n * Removes an item at the given index from an array.\r\n */\r\nexport function arrayRemoveAt<T>(arr: T[], idx: number) {\r\n    return arr.splice(idx, 1)[0];\r\n}","import type { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport { TypedEventBase } from \"kudzu/events/EventBase\";\r\nimport { sleep } from \"kudzu/events/sleep\";\r\nimport type { CallaEventType, CallaMetadataEvents } from \"../CallaEvents\";\r\nimport { CallaUserEvent } from \"../CallaEvents\";\r\nimport { ConnectionState } from \"../ConnectionState\";\r\nimport type { IMetadataClientExt } from \"./IMetadataClient\";\r\n\r\n\r\nexport abstract class BaseMetadataClient\r\n    extends TypedEventBase<CallaMetadataEvents>\r\n    implements IMetadataClientExt {\r\n\r\n    private tasks = new Map<string, Promise<any>>();\r\n\r\n    constructor(private sleepTime: number) {\r\n        super();\r\n    }\r\n\r\n    async getNext<T extends keyof CallaMetadataEvents>(evtName: T, userID: string): Promise<CallaMetadataEvents[T]> {\r\n        return new Promise((resolve) => {\r\n            const getter = (evt: CallaMetadataEvents[T]) => {\r\n                if (evt instanceof CallaUserEvent\r\n                    && evt.id === userID) {\r\n                    this.removeEventListener(evtName, getter);\r\n                    resolve(evt);\r\n                }\r\n            };\r\n\r\n            this.addEventListener(evtName, getter);\r\n        });\r\n    }\r\n\r\n    abstract get metadataState(): ConnectionState;\r\n\r\n    get isConnected(): boolean {\r\n        return this.metadataState === ConnectionState.Connected;\r\n    }\r\n\r\n    protected abstract callInternal(command: CallaEventType, ...args: any[]): Promise<void>;\r\n\r\n    private async callThrottled(key: string, command: CallaEventType, ...args: any[]): Promise<void> {\r\n        if (!this.tasks.has(key)) {\r\n            const start = performance.now();\r\n            const task = this.callInternal(command, ...args);\r\n            this.tasks.set(key, task);\r\n            await task;\r\n            const delta = performance.now() - start;\r\n            const sleepTime = this.sleepTime - delta;\r\n            if (sleepTime > 0) {\r\n                await sleep(this.sleepTime);\r\n            }\r\n            this.tasks.delete(key);\r\n        }\r\n    }\r\n\r\n    private async callImmediate(command: CallaEventType, ...args: any[]): Promise<void> {\r\n        await this.callInternal(command, ...args);\r\n    }\r\n\r\n    setLocalPose(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.callThrottled(\"userPosed\", \"userPosed\", px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPoseImmediate(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.callImmediate(\"userPosed\", px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPointer(name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.callThrottled(\"userPointer\" + name, \"userPointer\", name, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setAvatarEmoji(emoji: Emoji): void {\r\n        this.callImmediate(\"setAvatarEmoji\", emoji);\r\n    }\r\n\r\n    setAvatarURL(url: string): void {\r\n        this.callImmediate(\"avatarChanged\", url);\r\n    }\r\n\r\n    emote(emoji: Emoji): void {\r\n        this.callImmediate(\"emote\", emoji);\r\n    }\r\n\r\n    chat(text: string): void {\r\n        this.callImmediate(\"chat\", text);\r\n    }\r\n\r\n    abstract connect(): Promise<void>;\r\n    abstract join(roomName: string): Promise<void>;\r\n    abstract identify(userNameOrID: string): Promise<void>;\r\n    abstract leave(): Promise<void>;\r\n    abstract disconnect(): Promise<void>;\r\n}\r\n","export function sleep(dt: number) : Promise<void> {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, dt);\r\n    });\r\n}\r\n","/**\r\n * Scans through a series of filters to find an item that matches\r\n * any of the filters. The first item of the first filter that matches\r\n * will be returned.\r\n */\r\nexport function arrayScan<T>(arr: T[], ...tests: ((val: T) => boolean)[]) {\r\n    for (const test of tests) {\r\n        for (const item of arr) {\r\n            if (test(item)) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}","import { arrayScan } from \"kudzu/arrays/arrayScan\";\r\nimport type { ErsatzEventTarget } from \"kudzu/events/ErsatzEventTarget\";\r\nimport { TypedEventBase } from \"kudzu/events/EventBase\";\r\nimport { IFetcher } from \"kudzu/io/IFetcher\";\r\nimport { AudioManager } from \"../audio/AudioManager\";\r\nimport { canChangeAudioOutput } from \"../audio/canChangeAudioOutput\";\r\nimport type { MediaDeviceSet, MediaPermissionSet } from \"../Calla\";\r\nimport type { CallaTeleconferenceEvents } from \"../CallaEvents\";\r\nimport { CallaUserEvent } from \"../CallaEvents\";\r\nimport { ConnectionState } from \"../ConnectionState\";\r\nimport type { IMetadataClientExt } from \"../meta/IMetadataClient\";\r\nimport type { ITeleconferenceClientExt } from \"./ITeleconferenceClient\";\r\n\r\nexport function addLogger(obj: ErsatzEventTarget, evtName: string): void {\r\n    obj.addEventListener(evtName, (...rest: any[]) => {\r\n        if (loggingEnabled) {\r\n            console.log(\">== CALLA ==<\", evtName, ...rest);\r\n        }\r\n    });\r\n}\r\n\r\n\r\nfunction filterDeviceDuplicates(devices: MediaDeviceInfo[]) {\r\n    const filtered = [];\r\n    for (let i = 0; i < devices.length; ++i) {\r\n        const a = devices[i];\r\n        let found = false;\r\n        for (let j = 0; j < filtered.length && !found; ++j) {\r\n            const b = filtered[j];\r\n            found = a.kind === b.kind && b.label.indexOf(a.label) > 0;\r\n        }\r\n\r\n        if (!found) {\r\n            filtered.push(a);\r\n        }\r\n    }\r\n\r\n    return filtered;\r\n}\r\n\r\nconst PREFERRED_AUDIO_OUTPUT_ID_KEY = \"calla:preferredAudioOutputID\";\r\nconst PREFERRED_AUDIO_INPUT_ID_KEY = \"calla:preferredAudioInputID\";\r\nconst PREFERRED_VIDEO_INPUT_ID_KEY = \"calla:preferredVideoInputID\";\r\n\r\nexport const DEFAULT_LOCAL_USER_ID = \"local-user\";\r\n\r\nlet loggingEnabled = window.location.hostname === \"localhost\"\r\n    || /\\bdebug\\b/.test(window.location.search);\r\n\r\nexport abstract class BaseTeleconferenceClient\r\n    extends TypedEventBase<CallaTeleconferenceEvents>\r\n    implements ITeleconferenceClientExt {\r\n\r\n    toggleLogging() {\r\n        loggingEnabled = !loggingEnabled;\r\n    }\r\n\r\n    localUserID: string = null;\r\n    localUserName: string = null;\r\n    roomName: string = null;\r\n\r\n    protected fetcher: IFetcher;\r\n\r\n    audio: AudioManager;\r\n\r\n    private _connectionState = ConnectionState.Disconnected;\r\n    private _conferenceState = ConnectionState.Disconnected;\r\n\r\n    hasAudioPermission = false;\r\n    hasVideoPermission = false;\r\n\r\n    get connectionState(): ConnectionState {\r\n        return this._connectionState;\r\n    }\r\n\r\n    private setConnectionState(state: ConnectionState): void {\r\n        this._connectionState = state;\r\n    }\r\n\r\n    get conferenceState(): ConnectionState {\r\n        return this._conferenceState;\r\n    }\r\n\r\n    private setConferenceState(state: ConnectionState): void {\r\n        this._conferenceState = state;\r\n    }\r\n\r\n    constructor(fetcher: IFetcher, audio: AudioManager, public needsAudioDevice = true, public needsVideoDevice = false) {\r\n        super();\r\n\r\n        this.fetcher = fetcher;\r\n\r\n        this.audio = audio;\r\n\r\n        this.addEventListener(\"serverConnected\", this.setConnectionState.bind(this, ConnectionState.Connected));\r\n        this.addEventListener(\"serverFailed\", this.setConnectionState.bind(this, ConnectionState.Disconnected));\r\n        this.addEventListener(\"serverDisconnected\", this.setConnectionState.bind(this, ConnectionState.Disconnected));\r\n\r\n        this.addEventListener(\"conferenceJoined\", this.setConferenceState.bind(this, ConnectionState.Connected));\r\n        this.addEventListener(\"conferenceFailed\", this.setConferenceState.bind(this, ConnectionState.Disconnected));\r\n        this.addEventListener(\"conferenceRestored\", this.setConferenceState.bind(this, ConnectionState.Connected));\r\n        this.addEventListener(\"conferenceLeft\", this.setConferenceState.bind(this, ConnectionState.Disconnected));\r\n    }\r\n\r\n    dispatchEvent<K extends string & keyof CallaTeleconferenceEvents>(evt: CallaTeleconferenceEvents[K] & Event): boolean {\r\n        if (evt instanceof CallaUserEvent\r\n            && (evt.id == null\r\n                || evt.id === \"local\")) {\r\n            if (this.localUserID === DEFAULT_LOCAL_USER_ID) {\r\n                evt.id = null;\r\n            }\r\n            else {\r\n                evt.id = this.localUserID;\r\n            }\r\n        }\r\n\r\n        return super.dispatchEvent(evt);\r\n    }\r\n\r\n    async getNext<T extends keyof CallaTeleconferenceEvents>(evtName: T, userID: string): Promise<CallaTeleconferenceEvents[T]> {\r\n        return new Promise((resolve) => {\r\n            const getter = (evt: CallaTeleconferenceEvents[T]) => {\r\n                if (evt instanceof CallaUserEvent\r\n                    && evt.id === userID) {\r\n                    this.removeEventListener(evtName, getter);\r\n                    resolve(evt);\r\n                }\r\n            };\r\n\r\n            this.addEventListener(evtName, getter);\r\n        });\r\n    }\r\n\r\n\r\n\r\n    get preferredAudioInputID(): string {\r\n        return localStorage.getItem(PREFERRED_AUDIO_INPUT_ID_KEY);\r\n    }\r\n\r\n    set preferredAudioInputID(v: string) {\r\n        localStorage.setItem(PREFERRED_AUDIO_INPUT_ID_KEY, v);\r\n    }\r\n\r\n    get preferredVideoInputID(): string {\r\n        return localStorage.getItem(PREFERRED_VIDEO_INPUT_ID_KEY);\r\n    }\r\n\r\n    set preferredVideoInputID(v: string) {\r\n        localStorage.setItem(PREFERRED_VIDEO_INPUT_ID_KEY, v);\r\n    }\r\n\r\n    async setPreferredDevices(): Promise<void> {\r\n        await this.setPreferredAudioInput(true);\r\n        await this.setPreferredVideoInput(false);\r\n        await this.setPreferredAudioOutput(true);\r\n    }\r\n\r\n    async getPreferredAudioInput(allowAny: boolean): Promise<MediaDeviceInfo> {\r\n        const devices = await this.getAudioInputDevices();\r\n        const device = arrayScan(\r\n            devices,\r\n            (d) => d.deviceId === this.preferredAudioInputID,\r\n            (d) => d.deviceId === \"communications\",\r\n            (d) => d.deviceId === \"default\",\r\n            (d) => allowAny && d.deviceId.length > 0);\r\n        return device;\r\n    }\r\n\r\n    async setPreferredAudioInput(allowAny: boolean): Promise<void> {\r\n        const device = await this.getPreferredAudioInput(allowAny);\r\n        if (device) {\r\n            await this.setAudioInputDevice(device);\r\n        }\r\n    }\r\n\r\n    async getPreferredVideoInput(allowAny: boolean): Promise<MediaDeviceInfo> {\r\n        const devices = await this.getVideoInputDevices();\r\n        const device = arrayScan(devices,\r\n            (d) => d.deviceId === this.preferredVideoInputID,\r\n            (d) => allowAny && d && /front/i.test(d.label),\r\n            (d) => allowAny && d.deviceId.length > 0);\r\n        return device;\r\n    }\r\n\r\n    async setPreferredVideoInput(allowAny: boolean): Promise<void> {\r\n        const device = await this.getPreferredVideoInput(allowAny);\r\n        if (device) {\r\n            await this.setVideoInputDevice(device);\r\n        }\r\n    }\r\n\r\n    private async getDevices(): Promise<MediaDeviceInfo[]> {\r\n        let devices: MediaDeviceInfo[] = null;\r\n        for (let i = 0; i < 3; ++i) {\r\n            devices = await navigator.mediaDevices.enumerateDevices();\r\n            for (const device of devices) {\r\n                if (device.deviceId.length > 0) {\r\n                    this.hasAudioPermission = this.hasAudioPermission || device.kind === \"audioinput\" && device.label.length > 0;\r\n                    this.hasVideoPermission = this.hasVideoPermission || device.kind === \"videoinput\" && device.label.length > 0;\r\n                }\r\n            }\r\n\r\n            if (this.hasAudioPermission) {\r\n                break;\r\n            }\r\n\r\n            try {\r\n                await navigator.mediaDevices.getUserMedia({\r\n                    audio: this.needsAudioDevice && !this.hasAudioPermission,\r\n                    video: this.needsVideoDevice && !this.hasVideoPermission\r\n                });\r\n            }\r\n            catch (exp) {\r\n                console.warn(exp);\r\n            }\r\n        }\r\n\r\n        return devices || [];\r\n    }\r\n\r\n    async getMediaPermissions(): Promise<MediaPermissionSet> {\r\n        await this.getDevices();\r\n        return {\r\n            audio: this.hasAudioPermission,\r\n            video: this.hasVideoPermission\r\n        };\r\n    }\r\n\r\n    private async getAvailableDevices(filterDuplicates: boolean = false): Promise<MediaDeviceSet> {\r\n        let devices = await this.getDevices();\r\n\r\n        if (filterDuplicates) {\r\n            devices = filterDeviceDuplicates(devices);\r\n        }\r\n\r\n        return {\r\n            audioOutput: canChangeAudioOutput ? devices.filter(d => d.kind === \"audiooutput\") : [],\r\n            audioInput: devices.filter(d => d.kind === \"audioinput\"),\r\n            videoInput: devices.filter(d => d.kind === \"videoinput\")\r\n        };\r\n    }\r\n\r\n    async getAudioInputDevices(filterDuplicates: boolean = false): Promise<MediaDeviceInfo[]> {\r\n        const devices = await this.getAvailableDevices(filterDuplicates);\r\n        return devices && devices.audioInput || [];\r\n    }\r\n\r\n    async getVideoInputDevices(filterDuplicates: boolean = false): Promise<MediaDeviceInfo[]> {\r\n        const devices = await this.getAvailableDevices(filterDuplicates);\r\n        return devices && devices.videoInput || [];\r\n    }\r\n\r\n    async setAudioOutputDevice(device: MediaDeviceInfo) {\r\n        if (canChangeAudioOutput) {\r\n            this.preferredAudioOutputID = device && device.deviceId || null;\r\n        }\r\n    }\r\n\r\n    async getAudioOutputDevices(filterDuplicates: boolean = false): Promise<MediaDeviceInfo[]> {\r\n        if (!canChangeAudioOutput) {\r\n            return [];\r\n        }\r\n        const devices = await this.getAvailableDevices(filterDuplicates);\r\n        return devices && devices.audioOutput || [];\r\n    }\r\n\r\n    async getCurrentAudioOutputDevice() {\r\n        if (!canChangeAudioOutput) {\r\n            return null;\r\n        }\r\n        const curId = this.audio.getAudioOutputDeviceID(),\r\n            devices = await this.getAudioOutputDevices(),\r\n            device = devices.filter((d) => curId != null && d.deviceId === curId\r\n                || curId == null && d.deviceId === this.preferredAudioOutputID);\r\n        if (device.length === 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return device[0];\r\n        }\r\n    }\r\n\r\n    get preferredAudioOutputID(): string {\r\n        return localStorage.getItem(PREFERRED_AUDIO_OUTPUT_ID_KEY);\r\n    }\r\n\r\n    set preferredAudioOutputID(v: string) {\r\n        localStorage.setItem(PREFERRED_AUDIO_OUTPUT_ID_KEY, v);\r\n    }\r\n\r\n\r\n    async getPreferredAudioOutput(allowAny: boolean): Promise<MediaDeviceInfo> {\r\n        const devices = await this.getAudioOutputDevices();\r\n        const device = arrayScan(\r\n            devices,\r\n            (d) => d.deviceId === this.preferredAudioOutputID,\r\n            (d) => d.deviceId === \"communications\",\r\n            (d) => d.deviceId === \"default\",\r\n            (d) => allowAny && d.deviceId.length > 0);\r\n        return device;\r\n    }\r\n\r\n    async setPreferredAudioOutput(allowAny: boolean): Promise<void> {\r\n        const device = await this.getPreferredAudioOutput(allowAny);\r\n        if (device) {\r\n            await this.setAudioOutputDevice(device);\r\n        }\r\n    }\r\n\r\n    async setAudioInputDevice(device: MediaDeviceInfo): Promise<void> {\r\n        this.preferredAudioInputID = device && device.deviceId || null;\r\n    }\r\n\r\n    async setVideoInputDevice(device: MediaDeviceInfo) {\r\n        this.preferredVideoInputID = device && device.deviceId || null;\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        this.setConnectionState(ConnectionState.Connecting);\r\n    }\r\n\r\n    async join(_roomName: string, _password?: string): Promise<void> {\r\n        this.setConferenceState(ConnectionState.Connecting);\r\n    }\r\n\r\n    async leave(): Promise<void> {\r\n        this.setConferenceState(ConnectionState.Disconnecting);\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        this.setConnectionState(ConnectionState.Disconnecting);\r\n    }\r\n\r\n    abstract userExists(id: string): boolean;\r\n    abstract getUserNames(): string[][];\r\n    abstract identify(userNameOrID: string): Promise<void>;\r\n    abstract getCurrentAudioInputDevice(): Promise<MediaDeviceInfo>;\r\n    abstract getCurrentVideoInputDevice(): Promise<MediaDeviceInfo>;\r\n    abstract toggleAudioMuted(): Promise<boolean>;\r\n    abstract toggleVideoMuted(): Promise<boolean>;\r\n    abstract getAudioMuted(): Promise<boolean>;\r\n    abstract getVideoMuted(): Promise<boolean>;\r\n    abstract getDefaultMetadataClient(): IMetadataClientExt;\r\n}\r\n","/**\r\n * An Event class for tracking changes to audio activity.\r\n **/\r\nexport class AudioActivityEvent extends Event {\r\n    id: string = null;\r\n    isActive: boolean = false;\r\n\r\n    /** Creates a new \"audioActivity\" event */\r\n    constructor() {\r\n        super(\"audioActivity\");\r\n        Object.seal(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the current state of the event\r\n     * @param id - the user for which the activity changed\r\n     * @param isActive - the new state of the activity\r\n     */\r\n    set(id: string, isActive: boolean): void {\r\n        this.id = id;\r\n        this.isActive = isActive;\r\n    }\r\n}\r\n","import type { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport { TypedEventBase } from \"kudzu/events/EventBase\";\r\nimport type { IFetcher } from \"kudzu/io/IFetcher\";\r\nimport type { IDisposable } from \"kudzu/using\";\r\nimport { AudioActivityEvent } from \"./audio/AudioActivityEvent\";\r\nimport type { AudioManager } from \"./audio/AudioManager\";\r\nimport { canChangeAudioOutput } from \"./audio/canChangeAudioOutput\";\r\nimport type {\r\n    CallaAudioStreamAddedEvent,\r\n    CallaAudioStreamRemovedEvent,\r\n    CallaClientEvents,\r\n    CallaConferenceJoinedEvent,\r\n    CallaConferenceLeftEvent,\r\n    CallaParticipantJoinedEvent,\r\n    CallaParticipantLeftEvent,\r\n    CallaUserPointerEvent,\r\n    CallaUserPosedEvent\r\n} from \"./CallaEvents\";\r\nimport { ConnectionState } from \"./ConnectionState\";\r\nimport type { ICombinedClient } from \"./ICombinedClient\";\r\nimport type { IMetadataClient, IMetadataClientExt } from \"./meta/IMetadataClient\";\r\nimport type { ITeleconferenceClient, ITeleconferenceClientExt } from \"./tele/ITeleconferenceClient\";\r\n\r\nexport interface MediaPermissionSet {\r\n    audio: boolean;\r\n    video: boolean;\r\n}\r\n\r\nexport interface MediaDeviceSet {\r\n    audioInput: MediaDeviceInfo[];\r\n    videoInput: MediaDeviceInfo[];\r\n    audioOutput: MediaDeviceInfo[];\r\n}\r\n\r\nexport enum ClientState {\r\n    InConference = \"in-conference\",\r\n    JoiningConference = \"joining-conference\",\r\n    Connected = \"connected\",\r\n    Connecting = \"connecting\",\r\n    Prepaired = \"prepaired\",\r\n    Prepairing = \"prepairing\",\r\n    Unprepared = \"unprepaired\"\r\n}\r\n\r\nconst audioActivityEvt = new AudioActivityEvent();\r\n\r\nexport class Calla\r\n    extends TypedEventBase<CallaClientEvents>\r\n    implements ICombinedClient, IDisposable {\r\n\r\n    isAudioMuted: boolean = null;\r\n    isVideoMuted: boolean = null;\r\n\r\n    constructor(\r\n        private _fetcher: IFetcher,\r\n        private _tele: ITeleconferenceClientExt,\r\n        private _meta: IMetadataClientExt) {\r\n        super();\r\n\r\n        const fwd = this.dispatchEvent.bind(this);\r\n\r\n        this._tele.addEventListener(\"serverConnected\", fwd);\r\n        this._tele.addEventListener(\"serverDisconnected\", fwd);\r\n        this._tele.addEventListener(\"serverFailed\", fwd);\r\n        this._tele.addEventListener(\"conferenceFailed\", fwd);\r\n        this._tele.addEventListener(\"conferenceRestored\", fwd);\r\n\r\n        this._tele.addEventListener(\"audioMuteStatusChanged\", fwd);\r\n        this._tele.addEventListener(\"videoMuteStatusChanged\", fwd);\r\n\r\n        this._tele.addEventListener(\"conferenceJoined\", async (evt: CallaConferenceJoinedEvent) => {\r\n            const user = this.audio.setLocalUserID(evt.id);\r\n            evt.pose = user.pose;\r\n            this.dispatchEvent(evt);\r\n            await this.setPreferredDevices();\r\n        });\r\n\r\n        this._tele.addEventListener(\"conferenceLeft\", (evt: CallaConferenceLeftEvent) => {\r\n            this.audio.setLocalUserID(evt.id);\r\n            this.dispatchEvent(evt);\r\n        });\r\n\r\n        this._tele.addEventListener(\"participantJoined\", async (joinEvt: CallaParticipantJoinedEvent) => {\r\n            joinEvt.source = this.audio.createUser(joinEvt.id);\r\n            this.dispatchEvent(joinEvt);\r\n        });\r\n\r\n        this._tele.addEventListener(\"participantLeft\", (evt: CallaParticipantLeftEvent) => {\r\n            this.dispatchEvent(evt);\r\n            this.audio.removeUser(evt.id);\r\n        });\r\n\r\n        this._tele.addEventListener(\"userNameChanged\", fwd);\r\n        this._tele.addEventListener(\"videoAdded\", fwd);\r\n        this._tele.addEventListener(\"videoRemoved\", fwd);\r\n\r\n        this._tele.addEventListener(\"audioAdded\", (evt: CallaAudioStreamAddedEvent) => {\r\n            const user = this.audio.getUser(evt.id);\r\n            if (user) {\r\n                let stream = user.streams.get(evt.kind);\r\n                if (stream) {\r\n                    user.streams.delete(evt.kind);\r\n                }\r\n\r\n                stream = evt.stream;\r\n                user.streams.set(evt.kind, stream);\r\n\r\n                if (evt.id !== this._tele.localUserID) {\r\n                    this.audio.setUserStream(evt.id, stream);\r\n                }\r\n\r\n                this.dispatchEvent(evt);\r\n            }\r\n        });\r\n\r\n        this._tele.addEventListener(\"audioRemoved\", (evt: CallaAudioStreamRemovedEvent) => {\r\n            const user = this.audio.getUser(evt.id);\r\n            if (user && user.streams.has(evt.kind)) {\r\n                user.streams.delete(evt.kind);\r\n            }\r\n\r\n            if (evt.id !== this._tele.localUserID) {\r\n                this.audio.setUserStream(evt.id, null);\r\n            }\r\n\r\n            this.dispatchEvent(evt);\r\n        });\r\n\r\n        this._meta.addEventListener(\"avatarChanged\", fwd);\r\n        this._meta.addEventListener(\"chat\", fwd);\r\n        this._meta.addEventListener(\"emote\", fwd);\r\n        this._meta.addEventListener(\"setAvatarEmoji\", fwd);\r\n\r\n        const offsetEvt = (poseEvt: CallaUserPointerEvent | CallaUserPosedEvent): void => {\r\n            const O = this.audio.getUserOffset(poseEvt.id);\r\n            if (O) {\r\n                poseEvt.px += O[0];\r\n                poseEvt.py += O[1];\r\n                poseEvt.pz += O[2];\r\n            }\r\n            this.dispatchEvent(poseEvt);\r\n        };\r\n\r\n        this._meta.addEventListener(\"userPointer\", offsetEvt);\r\n\r\n        this._meta.addEventListener(\"userPosed\", (evt: CallaUserPosedEvent) => {\r\n            this.audio.setUserPose(\r\n                evt.id,\r\n                evt.px, evt.py, evt.pz,\r\n                evt.fx, evt.fy, evt.fz,\r\n                evt.ux, evt.uy, evt.uz);\r\n            offsetEvt(evt);\r\n        });\r\n\r\n        this.audio.addEventListener(\"audioActivity\", (evt: AudioActivityEvent) => {\r\n            audioActivityEvt.id = evt.id;\r\n            audioActivityEvt.isActive = evt.isActive;\r\n            this.dispatchEvent(audioActivityEvt);\r\n        });\r\n\r\n        const dispose = this.dispose.bind(this);\r\n        window.addEventListener(\"beforeunload\", dispose);\r\n        window.addEventListener(\"unload\", dispose);\r\n        window.addEventListener(\"pagehide\", dispose);\r\n\r\n        Object.seal(this);\r\n    }\r\n\r\n    get connectionState(): ConnectionState {\r\n        return this._tele.connectionState;\r\n    }\r\n\r\n    get conferenceState(): ConnectionState {\r\n        return this._tele.conferenceState;\r\n    }\r\n\r\n    get fetcher(): IFetcher {\r\n        return this._fetcher;\r\n    }\r\n\r\n    get tele(): ITeleconferenceClient {\r\n        return this._tele;\r\n    }\r\n\r\n    get meta(): IMetadataClient {\r\n        return this._meta;\r\n    }\r\n\r\n    get audio(): AudioManager {\r\n        return this._tele.audio;\r\n    }\r\n\r\n    get preferredAudioOutputID(): string {\r\n        return this._tele.preferredAudioOutputID;\r\n    }\r\n\r\n    set preferredAudioOutputID(v: string) {\r\n        this._tele.preferredAudioOutputID = v;\r\n    }\r\n\r\n    get preferredAudioInputID(): string {\r\n        return this._tele.preferredAudioInputID;\r\n    }\r\n\r\n    set preferredAudioInputID(v: string) {\r\n        this._tele.preferredAudioInputID = v;\r\n    }\r\n\r\n    get preferredVideoInputID(): string {\r\n        return this._tele.preferredVideoInputID;\r\n    }\r\n\r\n    set preferredVideoInputID(v: string) {\r\n        this._tele.preferredVideoInputID = v;\r\n    }\r\n\r\n    async getCurrentAudioOutputDevice(): Promise<MediaDeviceInfo> {\r\n        return await this._tele.getCurrentAudioOutputDevice();\r\n    }\r\n\r\n    async getMediaPermissions(): Promise<MediaPermissionSet> {\r\n        return await this._tele.getMediaPermissions();\r\n    }\r\n\r\n    async getAudioOutputDevices(filterDuplicates: boolean): Promise<MediaDeviceInfo[]> {\r\n        return await this._tele.getAudioOutputDevices(filterDuplicates);\r\n    }\r\n\r\n    async getAudioInputDevices(filterDuplicates: boolean): Promise<MediaDeviceInfo[]> {\r\n        return await this._tele.getAudioInputDevices(filterDuplicates);\r\n    }\r\n\r\n    async getVideoInputDevices(filterDuplicates: boolean): Promise<MediaDeviceInfo[]> {\r\n        return await this._tele.getVideoInputDevices(filterDuplicates);\r\n    }\r\n\r\n    dispose(): void {\r\n        this.leave();\r\n        this.disconnect();\r\n    }\r\n\r\n    get offsetRadius(): number {\r\n        return this.audio.offsetRadius;\r\n    }\r\n\r\n    set offsetRadius(v: number) {\r\n        this.audio.offsetRadius = v;\r\n    }\r\n\r\n    setLocalPose(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.audio.setUserPose(this.localUserID, px, py, pz, fx, fy, fz, ux, uy, uz, 0);\r\n        this._meta.setLocalPose(px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPoseImmediate(px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this.audio.setUserPose(this.localUserID, px, py, pz, fx, fy, fz, ux, uy, uz, 0);\r\n        this._meta.setLocalPoseImmediate(px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setLocalPointer(name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number): void {\r\n        this._meta.setLocalPointer(name, px, py, pz, fx, fy, fz, ux, uy, uz);\r\n    }\r\n\r\n    setAvatarEmoji(emoji: Emoji): void {\r\n        this._meta.setAvatarEmoji(emoji);\r\n    }\r\n\r\n    setAvatarURL(url: string): void {\r\n        this._meta.setAvatarURL(url);\r\n    }\r\n\r\n    emote(emoji: Emoji): void {\r\n        this._meta.emote(emoji);\r\n    }\r\n\r\n    chat(text: string): void {\r\n        this._meta.chat(text);\r\n    }\r\n\r\n    async setPreferredDevices(): Promise<void> {\r\n        await this._tele.setPreferredDevices();\r\n    }\r\n\r\n    async setAudioInputDevice(device: MediaDeviceInfo): Promise<void> {\r\n        await this._tele.setAudioInputDevice(device);\r\n    }\r\n\r\n    async setVideoInputDevice(device: MediaDeviceInfo): Promise<void> {\r\n        await this._tele.setVideoInputDevice(device);\r\n    }\r\n\r\n    async getCurrentAudioInputDevice(): Promise<MediaDeviceInfo> {\r\n        return await this._tele.getCurrentAudioInputDevice();\r\n    }\r\n\r\n    async getCurrentVideoInputDevice(): Promise<MediaDeviceInfo> {\r\n        return await this._tele.getCurrentVideoInputDevice();\r\n    }\r\n\r\n    async toggleAudioMuted(): Promise<boolean> {\r\n        return await this._tele.toggleAudioMuted();\r\n    }\r\n\r\n    async toggleVideoMuted(): Promise<boolean> {\r\n        return await this._tele.toggleVideoMuted();\r\n    }\r\n\r\n    async getAudioMuted(): Promise<boolean> {\r\n        return await this._tele.getAudioMuted();\r\n    }\r\n\r\n    async getVideoMuted(): Promise<boolean> {\r\n        return await this._tele.getVideoMuted();\r\n    }\r\n\r\n    get metadataState(): ConnectionState {\r\n        return this._meta.metadataState;\r\n    }\r\n\r\n    get localUserID() {\r\n        return this._tele.localUserID;\r\n    }\r\n\r\n    get localUserName() {\r\n        return this._tele.localUserName;\r\n    }\r\n\r\n    get roomName() {\r\n        return this._tele.roomName;\r\n    }\r\n\r\n    userExists(id: string): boolean {\r\n        return this._tele.userExists(id);\r\n    }\r\n\r\n    getUserNames(): string[][] {\r\n        return this._tele.getUserNames();\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        await this._tele.connect();\r\n        if (this._tele.connectionState === ConnectionState.Connected) {\r\n            await this._meta.connect();\r\n        }\r\n    }\r\n\r\n    async join(roomName: string): Promise<void> {\r\n        await this._tele.join(roomName);\r\n        if (this._tele.conferenceState === ConnectionState.Connected) {\r\n            await this._meta.join(roomName);\r\n        }\r\n    }\r\n\r\n    async identify(userName: string): Promise<void> {\r\n        await this._tele.identify(userName);\r\n        await this._meta.identify(this.localUserID);\r\n    }\r\n\r\n    async leave(): Promise<void> {\r\n        await this._meta.leave();\r\n        await this._tele.leave();\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        await this._meta.disconnect();\r\n        await this._tele.disconnect();\r\n    }\r\n\r\n    update(): void {\r\n        this.audio.update();\r\n    }\r\n\r\n    async setAudioOutputDevice(device: MediaDeviceInfo) {\r\n        this._tele.setAudioOutputDevice(device);\r\n        if (canChangeAudioOutput) {\r\n            await this.audio.setAudioOutputDeviceID(this._tele.preferredAudioOutputID);\r\n        }\r\n    }\r\n\r\n    async setAudioMuted(muted: boolean) {\r\n        let isMuted = this.isAudioMuted;\r\n        if (muted !== isMuted) {\r\n            isMuted = await this.toggleAudioMuted();\r\n        }\r\n        return isMuted;\r\n    }\r\n\r\n    async setVideoMuted(muted: boolean) {\r\n        let isMuted = this.isVideoMuted;\r\n        if (muted !== isMuted) {\r\n            isMuted = await this.toggleVideoMuted();\r\n        }\r\n        return isMuted;\r\n    }\r\n\r\n}","export * from \"./audio/canChangeAudioOutput\";\r\nexport * from \"./meta/signalr/SignalRMetadataClient\";\r\nexport * from \"./meta/BaseMetadataClient\";\r\nexport * from \"./tele/BaseTeleconferenceClient\";\r\nexport { Calla as Client } from \"./Calla\";\r\nexport {\r\n    CallaTeleconferenceEventType as TeleconferenceEvents,\r\n    CallaMetadataEventType as MetadataEvents\r\n} from \"./CallaEvents\";\r\n\r\nimport { version } from \"./package.json\";\r\nconsole.info(`Calla v${version}.`);\r\n\r\nexport { version };","import { HubConnection, HubConnectionState } from \"../../signalr/HubConnection\";\r\nimport { HubConnectionBuilder } from \"../../signalr/HubConnectionBuilder\";\r\nimport { HttpTransportType } from \"../../signalr/ITransport\";\r\nimport type { Emoji } from \"kudzu/emoji/Emoji\";\r\nimport { waitFor } from \"kudzu/events/waitFor\";\r\nimport { assertNever } from \"kudzu/typeChecks\";\r\nimport type { CallaEventType } from \"../../CallaEvents\";\r\nimport {\r\n    CallaAvatarChangedEvent,\r\n    CallaChatEvent,\r\n    CallaEmojiAvatarEvent,\r\n    CallaEmoteEvent,\r\n    CallaUserPointerEvent,\r\n    CallaUserPosedEvent\r\n} from \"../../CallaEvents\";\r\nimport { ConnectionState } from \"../../ConnectionState\";\r\nimport { BaseMetadataClient } from \"../BaseMetadataClient\";\r\n\r\nexport class SignalRMetadataClient\r\n    extends BaseMetadataClient {\r\n\r\n    private hub: HubConnection;\r\n    private lastRoom: string = null;\r\n    private lastUserID: string = null;\r\n    private currentRoom: string = null;\r\n    private currentUserID: string = null;\r\n\r\n    constructor(signalRPath: string) {\r\n        super(50);\r\n\r\n        this.hub = new HubConnectionBuilder()\r\n            .withUrl(signalRPath, HttpTransportType.WebSockets)\r\n            .build();\r\n\r\n        this.hub.onclose(() => {\r\n            this.lastRoom = null;\r\n            this.lastUserID = null;\r\n        });\r\n\r\n        this.hub.on(\"userPosed\",\r\n            (fromUserID: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) => {\r\n                this.dispatchEvent(new CallaUserPosedEvent(fromUserID, px, py, pz, fx, fy, fz, ux, uy, uz));\r\n            });\r\n\r\n        this.hub.on(\"userPointer\",\r\n            (fromUserID: string, name: string, px: number, py: number, pz: number, fx: number, fy: number, fz: number, ux: number, uy: number, uz: number) => {\r\n                this.dispatchEvent(new CallaUserPointerEvent(fromUserID, name, px, py, pz, fx, fy, fz, ux, uy, uz));\r\n            });\r\n\r\n        this.hub.on(\"avatarChanged\",\r\n            (fromUserID: string, url: string) => {\r\n                this.dispatchEvent(new CallaAvatarChangedEvent(fromUserID, url));\r\n            });\r\n\r\n        this.hub.on(\"emote\",\r\n            (fromUserID: string, emoji: Emoji) => {\r\n                this.dispatchEvent(new CallaEmoteEvent(fromUserID, emoji));\r\n            });\r\n\r\n        this.hub.on(\"setAvatarEmoji\",\r\n            (fromUserID: string, emoji: Emoji) => {\r\n                this.dispatchEvent(new CallaEmojiAvatarEvent(fromUserID, emoji));\r\n            });\r\n\r\n        this.hub.on(\"chat\",\r\n            (fromUserID: string, text: string) => {\r\n                this.dispatchEvent(new CallaChatEvent(fromUserID, text));\r\n            });\r\n    }\r\n\r\n    get metadataState() {\r\n        switch (this.hub.state) {\r\n            case HubConnectionState.Connected: return ConnectionState.Connected;\r\n            case HubConnectionState.Connecting: case HubConnectionState.Reconnecting: return ConnectionState.Connecting;\r\n            case HubConnectionState.Disconnected: return ConnectionState.Disconnected;\r\n            case HubConnectionState.Disconnecting: return ConnectionState.Disconnecting;\r\n            default: assertNever(this.hub.state);\r\n        }\r\n    }\r\n\r\n    private async maybeStart(): Promise<void> {\r\n        if (this.metadataState === ConnectionState.Connecting) {\r\n            await waitFor(() => this.metadataState === ConnectionState.Connected);\r\n        }\r\n        else {\r\n            if (this.metadataState === ConnectionState.Disconnecting) {\r\n                await waitFor(() => this.metadataState === ConnectionState.Disconnected);\r\n            }\r\n\r\n            if (this.metadataState === ConnectionState.Disconnected) {\r\n                await this.hub.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    private async maybeJoin(): Promise<void> {\r\n        await this.maybeStart();\r\n\r\n        if (this.currentRoom !== this.lastRoom) {\r\n            await this.maybeLeave();\r\n\r\n            if (this.currentRoom && this.isConnected) {\r\n                this.lastRoom = this.currentRoom;\r\n                await this.hub.invoke(\"join\", this.currentRoom);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async maybeIdentify(): Promise<void> {\r\n        await this.maybeJoin();\r\n\r\n        if (this.currentUserID\r\n            && this.currentUserID !== this.lastUserID\r\n            && this.isConnected) {\r\n            this.lastUserID = this.currentUserID;\r\n            await this.hub.invoke(\"identify\", this.currentUserID);\r\n        }\r\n    }\r\n\r\n    private async maybeLeave(): Promise<void> {\r\n        if (this.isConnected) {\r\n            await this.hub.invoke(\"leave\");\r\n        }\r\n    }\r\n\r\n    private async maybeDisconnect() {\r\n        if (this.metadataState === ConnectionState.Disconnecting) {\r\n            await waitFor(() => this.metadataState === ConnectionState.Disconnected);\r\n        }\r\n        else {\r\n            if (this.metadataState === ConnectionState.Connecting) {\r\n                await waitFor(() => this.metadataState === ConnectionState.Connected);\r\n            }\r\n\r\n            if (this.metadataState === ConnectionState.Connected) {\r\n                await this.hub.stop();\r\n            }\r\n        }\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        await this.maybeStart();\r\n    }\r\n\r\n    async join(roomName: string): Promise<void> {\r\n        this.currentRoom = roomName;\r\n        await this.maybeJoin();\r\n    }\r\n\r\n    async identify(userID: string): Promise<void> {\r\n        this.currentUserID = userID;\r\n        await this.maybeJoin();\r\n        await this.maybeIdentify();\r\n    }\r\n\r\n    async leave(): Promise<void> {\r\n        await this.maybeLeave();\r\n        this.currentUserID\r\n            = this.lastUserID\r\n            = this.currentRoom\r\n            = this.lastRoom\r\n            = null;\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        await this.maybeDisconnect();\r\n        this.currentUserID\r\n            = this.lastUserID\r\n            = this.currentRoom\r\n            = this.lastRoom\r\n            = null;\r\n    }\r\n\r\n    protected async callInternal(command: CallaEventType, toUserID: string, ...args: any[]): Promise<void> {\r\n        await this.maybeIdentify();\r\n        if (this.isConnected) {\r\n            await this.hub.invoke(command, toUserID, ...args);\r\n        }\r\n    }\r\n}\r\n"],"names":["isFunction","obj","o","c","Function","canChangeAudioOutput","HTMLAudioElement","prototype","setSinkId","TextMessageFormat","[object Object]","output","RecordSeparator","input","length","Error","messages","split","pop","LogLevel","String","fromCharCode","RecordSeparatorCode","NullLogger","_logLevel","_message","Arg","val","name","match","values","Platform","isBrowser","window","isWebWorker","self","getDataDetail","data","includeContent","detail","isArrayBuffer","byteLength","view","Uint8Array","str","forEach","num","toString","substr","formatArrayBuffer","ArrayBuffer","constructor","async","sendMessage","logger","transportName","httpClient","url","accessTokenFactory","content","logMessageContent","withCredentials","defaultHeaders","headers","token","Authorization","value","getUserAgentHeader","log","Trace","responseType","response","post","statusCode","SubjectSubscription","subject","observer","this","index","observers","indexOf","splice","cancelCallback","catch","_","ConsoleLogger","minimumLogLevel","outputConsole","console","logLevel","message","Critical","error","Date","toISOString","Warning","warn","Information","info","constructUserAgent","navigator","platform","undefined","version","os","runtime","runtimeVersion","userAgent","majorAndMinor","HandshakeProtocol","handshakeRequest","write","JSON","stringify","responseMessage","messageData","remainingData","binaryData","separatorIndex","responseLength","apply","slice","buffer","textData","substring","parse","type","MessageType","Subject","item","next","err","complete","push","HubConnectionState","HubConnection","connection","protocol","reconnectPolicy","isRequired","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","handshakeProtocol","onreceive","processIncomingData","onclose","connectionClosed","callbacks","methods","closedCallbacks","reconnectingCallbacks","reconnectedCallbacks","invocationId","receivedHandshakeResponse","connectionState","Disconnected","connectionStarted","cachedPingMessage","writeMessage","Ping","state","connectionId","baseUrl","Reconnecting","startPromise","startWithStateTransitions","Promise","reject","Connecting","Debug","startInternal","Connected","e","stopDuringStartError","handshakePromise","resolve","handshakeResolver","handshakeRejecter","start","transferFormat","writeHandshakeRequest","cleanupTimeout","resetTimeoutPeriod","resetKeepAliveInterval","cleanupPingTimer","stop","stopPromise","stopInternal","Disconnecting","reconnectDelayHandle","clearTimeout","completeClose","methodName","args","streams","streamIds","replaceStreamingParams","invocationDescriptor","createStreamInvocation","promiseQueue","cancelInvocation","createCancelInvocation","then","sendWithProtocol","invocationEvent","Completion","launchStreams","send","sendPromise","createInvocation","result","newMethod","toLowerCase","method","handlers","removeIdx","callback","processHandshakeResponse","parseMessages","Invocation","invokeClientMethod","StreamItem","Close","allowReconnect","parseHandshakeResponse","features","inherentKeepAlive","pingServerHandle","setTimeout","timeoutHandle","serverTimeout","invocationMessage","target","m","arguments","cancelCallbacksWithError","reconnect","reconnectStartTime","now","previousReconnectAttempts","retryError","nextRetryDelay","getNextRetryDelay","onreconnecting","onreconnected","previousRetryCount","elapsedMilliseconds","retryReason","nextRetryDelayInMilliseconds","Object","keys","key","nonblocking","streamId","subscribe","createCompletionMessage","createStreamItemMessage","i","argument","isObservable","arg","StreamInvocation","id","CancelInvocation","DEFAULT_RETRY_DELAYS_IN_MILLISECONDS","DefaultReconnectPolicy","retryDelays","retryContext","HttpError","errorMessage","trueProto","super","__proto__","TimeoutError","AbortError","HttpResponse","statusText","HttpClient","options","FetchHttpClient","fetch","requireFunc","__webpack_require__","__non_webpack_require__","require","jar","CookieJar","fetchType","abortControllerType","bind","AbortController","request","abortSignal","aborted","abortController","onabort","abort","timeoutId","timeout","msTimeout","body","cache","credentials","Content-Type","X-Requested-With","mode","redirect","signal","ok","status","arrayBuffer","text","deserializeContent","payload","XhrHttpClient","xhr","XMLHttpRequest","open","setRequestHeader","header","onload","responseText","onerror","ontimeout","DefaultHttpClient","HttpTransportType","TransferFormat","isAborted","LongPollingTransport","pollAbort","running","pollAborted","isIn","Binary","pollOptions","getAccessToken","updateHeaderToken","pollUrl","get","closeError","receiving","poll","raiseOnClose","deleteOptions","delete","logMessage","ServerSentEventsTransport","eventSourceConstructor","encodeURIComponent","eventSource","opened","Text","onmessage","close","onopen","WebSocketTransport","webSocketConstructor","webSocket","replace","binaryType","_event","event","ErrorEvent","readyState","OPEN","isCloseEvent","wasClean","code","reason","HttpConnection","instance","resolveUrl","WebSocket","EventSource","startInternalPromise","sendQueue","TransportSendQueue","transport","stopPromiseResolver","stopError","stopConnection","skipNegotiation","WebSockets","constructTransport","startTransport","negotiateResponse","redirects","getNegotiationResponse","ProtocolVersion","accessToken","createTransport","negotiateUrl","resolveNegotiateUrl","negotiateVersion","connectionToken","requestedTransport","requestedTransferFormat","connectUrl","createConnectUrl","isITransport","transportExceptions","transports","availableTransports","negotiate","endpoint","transportOrError","resolveTransportOrError","ex","join","ServerSentEvents","LongPolling","connect","actualTransport","transportMatches","transferFormats","map","s","lastIndexOf","document","aTag","createElement","href","sendBufferedData","PromiseSource","transportResult","sendLoopPromise","sendLoop","bufferData","promise","executing","concatBuffers","arrayBuffers","totalLength","b","reduce","a","offset","set","resolver","rejecter","JsonHubProtocol","hubMessages","parsedMessage","isInvocationMessage","isStreamItemMessage","isCompletionMessage","assertNotEmptyString","LogLevelNameMapping","trace","debug","information","warning","critical","none","None","HubConnectionBuilder","logging","mapping","parseLogLevel","transportTypeOrOptions","isNotEmpty","httpConnectionOptions","retryDelaysOrReconnectPolicy","Array","isArray","create","waitFor","test","handle","setInterval","clearInterval","Emoji","desc","props","contains","CallaEvent","Event","eventType","CallaUserEvent","StreamType","StreamOpType","ConnectionState","CallaPoseEvent","px","py","pz","fx","fy","fz","ux","uy","uz","CallaUserPosedEvent","CallaUserPointerEvent","CallaEmojiEvent","emoji","CallaEmoteEvent","CallaEmojiAvatarEvent","CallaAvatarChangedEvent","CallaChatEvent","TypedEventBase","Map","listeners","find","listenerOptions","removeListener","idx","findIndex","arr","arrayRemoveAt","has","evt","once","call","defaultPrevented","mappedCallback","mappedCallbacks","addEventListener","removeEventListener","BaseMetadataClient","sleepTime","evtName","userID","getter","isConnected","metadataState","command","tasks","performance","task","callInternal","delta","dt","callThrottled","callImmediate","arrayScan","tests","PREFERRED_AUDIO_OUTPUT_ID_KEY","PREFERRED_AUDIO_INPUT_ID_KEY","PREFERRED_VIDEO_INPUT_ID_KEY","DEFAULT_LOCAL_USER_ID","loggingEnabled","location","hostname","search","AudioActivityEvent","seal","isActive","ClientState","audioActivityEvt","fetcher","audio","needsAudioDevice","needsVideoDevice","setConnectionState","setConferenceState","_connectionState","conferenceState","_conferenceState","localUserID","dispatchEvent","preferredAudioInputID","localStorage","getItem","v","setItem","preferredVideoInputID","setPreferredAudioInput","setPreferredVideoInput","setPreferredAudioOutput","allowAny","getAudioInputDevices","d","deviceId","device","getPreferredAudioInput","setAudioInputDevice","getVideoInputDevices","label","getPreferredVideoInput","setVideoInputDevice","devices","mediaDevices","enumerateDevices","hasAudioPermission","kind","hasVideoPermission","getUserMedia","video","exp","getDevices","filterDuplicates","filtered","found","j","filterDeviceDuplicates","audioOutput","filter","audioInput","videoInput","getAvailableDevices","preferredAudioOutputID","curId","getAudioOutputDeviceID","getAudioOutputDevices","getPreferredAudioOutput","setAudioOutputDevice","_roomName","_password","_fetcher","_tele","_meta","fwd","user","setLocalUserID","pose","setPreferredDevices","joinEvt","source","createUser","removeUser","getUser","stream","setUserStream","offsetEvt","poseEvt","O","getUserOffset","setUserPose","dispose","tele","meta","getCurrentAudioOutputDevice","getMediaPermissions","leave","disconnect","offsetRadius","setLocalPose","setLocalPoseImmediate","setLocalPointer","setAvatarEmoji","setAvatarURL","emote","chat","getCurrentAudioInputDevice","getCurrentVideoInputDevice","toggleAudioMuted","toggleVideoMuted","getAudioMuted","getVideoMuted","localUserName","roomName","userExists","getUserNames","userName","identify","update","setAudioOutputDeviceID","muted","isMuted","isAudioMuted","isVideoMuted","signalRPath","hub","withUrl","build","lastRoom","lastUserID","on","fromUserID","x","msg","assertNever","maybeStart","currentRoom","maybeLeave","invoke","maybeJoin","currentUserID","maybeIdentify","maybeDisconnect","toUserID","rest"],"mappings":"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"}